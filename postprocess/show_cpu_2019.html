<!DOCTYPE html>
<html>
<!-- 
  - by Dick Sites 2018.11.29, 2019.01.02, 2019.05.06
  -  complete rewrite
  -
  - Copyright (C) 2019 Richard L. Sites
  -
  - This program is free software: you can redistribute it and/or modify
  - it under the terms of the GNU General Public License as published by
  - the Free Software Foundation, either version 3 of the License, or
  - (at your option) any later version.
  -
  - This program is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU General Public License
  - along with this program.  If not, see <https://www.gnu.org/licenses/>.
  -
  - Actions you can do:
  -  Drag/zoom timeline with mouse and wheel in main display area
  -  Drag/zoom Y-axis with mouse and wheel in left axis area
  -  Click on red dot lower left to reset to original view
  -
  -  Shift-click on an item to see what it is:
  -    idle: black line
  -    user-mode: half-high stacked two lines, colored by by pid
  -    kernel-mode: full-high by overlaid two lines plus background color 
  -      green=syscall, blue=interrupt, red=fault
  -    red sine wave shows approx. C-state exit time from mwait power saving
  -  Releasing click first erases annotation   
  -  Releasing shift first leaves annotation on screen
  -  Shift-click-drag to annotate start and stop items, with time between  
  -    shown; release behavior above
  -
  -  File: input box takes the name of an input json file.
  -  IPC button toggles showing instruction pre cycle data, if available 
  -  Marks button toggles showing mark annotations in the trace
  -  Annotate button toggles labelling everything on the screen; most useful 
  -    when zoomed in
  -  User-mode button toggles labelling just the first instance of each 
  -    user-mode process name
  -  Search negate button shows non-matches (like grep -v) 
  -  Search input box labels everything on the screen that matches the search 
  -    string; full javascript regex. For example, search-box text for 
  -    annotating for all items without "page" or "bash"
  -      ^((?!(page)|(bash)).)*$
  -  Search usec range limits matches to events with duration in that range
  -
  -  Shift-click of some buttons cycles through more-detailed choices
  -
  -  Shift-click on title at top center toggles/cycles text size
  -  Shift-click on base time at lower left toggles relative vs. absolute times
  -
  -  Shift-click on 0(arrow)-5 at lower right saves current state
  -  Click on 0(arrow)-5 at lower right does current to 0, 0-5 to current 
  -
  -  Note: edge complains bad syntax expecting end if line inside comment begins --
  -->
<meta charset="UTF-8">
 
<head>

 
<style> /* set the CSS */
.noselect {user-select: none;}

.verticalline {
  fill: none;
  stroke: #AA00FF;	/* bluish magenta */
  stroke-width: 1px;
}
.verticaldashline {
  fill: none;
  stroke: #AA00FF;
  stroke-width: 1px;
  stroke-dasharray: 2,5;
}

.rubberline {
  fill: none;
  stroke: #AA00FF;
  stroke-width: 4px;
}

.markertext {
  text-anchor: left;
  font-family: sans-serif; 
  fill: #AA00FF;
}

.rubbertext {
  text-anchor: middle;
  font-family: sans-serif; 
  fill: #AA00FF;
}

.brackettext {
  text-anchor: middle;
  font-family: sans-serif; 
  fill: #000000;
}
 
.graphline {
  fill: none;
  stroke: steelblue;
  stroke-width: 2px;
}
 
.tick { font-size: axisTickPx; font-family: sans-serif; }
//.tick { font-size: 15px; font-family: sans-serif; }

/* .axis { font-size: 12px; } */
/* .axis-text { font-size: 30px;  fill: red; } */
/* .axis-text { font-size: 18px; font-family: sans-serif; } */
</style>
 
 
<!-- Load the d3.js library -->    	
<!-- selfcontained0 -->
<script src="https://d3js.org/d3.v4.min.js"></script>

<script type="text/javascript">
<!-- selfcontained1 -->


// Screen layout:
//
// Given a browser window size, subdivide it into seven regions
//
// +------------------------------------------------------------------------+
// |            (0) UI controls (HTML)                                      |
// +------------------------------------------------------------------------+
// |            (1) Title                                                   |
// +----+--------------------------------------------------------------+----+
// |(2) |                                                              |(4) |
// |Y-  |       (3) Main SVG drawing area                              |IPC |
// |axis|                                                              |    |
// |    |                                                              |    |
// +----+--------------------------------------------------------------+----+
//      |       (5) X-axis                                             |
//      |                                                              |
// +----+--------------------------------------------------------------+----+
// |            (6) UI hint text (HTML)                                     |
// +----+--------------------------------------------------------------+----+
//
//
// A note on mapping for the Y-axis
//
// The Y-axis displays events in multiple rows, in four groups: by CPU number, 
// by process ID (PID)_ number, by remote procedure call (RPC) number, and by 
// busy-resource (RES) number. Each event may be displayed up to four times on 
// four separate but time-aligned rows. Individual groups may be collapsed or
// expanded by clicking on the blue group label at the left side of Region 2.
// Groups are numbered 0..3 via prefixCpu, etc. Resources are typically a
// held lock number, but may also be a disk or network or other shared-resource
// number.
//
// Rows vary in height. Normally, they are full-size, but may be shrunk when
// a group is collapsed or when highlighting (below) is used. In addition, the 
// Y-axis may be panned and zoomed. The net effect is that multiple levels of 
// mapping and terminology are used to determine the Y-pixel coordinate(s) 
// for displaying any event.
//
// Events are numbered 0..N-1 in the data.events array. N can be a million
// or more. Event numbers are assigned once whenever new data is loaded.
//
// Each event's CPU, PID, RPC, and <tbd> field can be mapped to one of up to 
// M rows via the array eventToRow[256K], subscripted by the low 16 bits 
// of the respective field plus 64K times the group number. There is no mapping 
// and no display if the field value is negative. For a trace with 100 CPUs 
// and 100 different PIDs and 100 different RPC IDs and 100 different busy
// resources, M would be 400. Row numbers are assigned once whenever new data 
// is loaded.
//
// Each row in turn is mapped into a height in tracks and assigned a track 
// number via the arrays rowToHeight[M]and rowToTrack[M]. The heights are 
// assigned whenever the group expand/collapse or highlighting changes, and the 
// track numbers are then calculated as the running sum of heights.
//
// Each group can be expanded to show every row within the group or collapsed 
// to show no rows. When a group is expanded, highlighted rows are full height, 
// but non-highlighted rows and be one of three selected heights -- currently
// full 20 or 5 or 1 track. Collapsed rows have height 0. 

// Track heights and numbers are reassigned dynamically whenever groups are 
// expanded or collapsed, highlights are changed, or auto-pruning (below) 
// occurs.
//
// Track numbers are the the input to Y-axis scaling (domain) and the output 
// is a Y-direction pixel number within Region 2 (range). Panning and zooming
// the Y-axis only affects this last mapping, leaving the others unchanged.
//
// Highlighting
// One or more rows can be highlighted, which keeps each event in a highlighted 
// row and in every other row the event occurs drawn in color, with all non-
// highlighted events drawn in gray. If no rows are highlighted, the effect is
// That all events are drawn in color. In addition to the change for color to 
// gray for non-highlighted events, rows consisting entirely of non-highlighted
// events may be shrunk vertically to further de-emphasize them while still
// retaining some amount of surrounding context for the highlighted events.
//
// Auto-pruning
// The events in a row have a containing time range from the earliest event
// timestamp to the latest timestamp-plus-duration. Some rows have a range that
// covers almost the entire trace, but other rows have quite limited ranges 
// because they represent a process that starts, runs, and stops during the 
// trace, or they represent an RPC that arrives, runs, and terminates. If a 
// trace has 100 RPCs but the X-axis is panned and zoomed to only display a 
// subset of the trace that contains only portions of five RPCs, it can be 
// helpful to suppress all the blank rows that represent RPCs that do not 
// overlap the displayed timespan. Auto-pruning removes (assigns height 0) all 
// rows whose time range fails to overlap the displayed range. 
//
// The effect of this feature is that panning and zooming the X-axis can also
// change the Y-axis.
//



//
//============================================================================//
// Main data structures:
//
// The data struct contains all the input data to be drawn. It is either loaded 
// from an external JSON file via d3.json, or from an internal string via 
// JSON.parse(myString).
// The struct contains at least these variables:
// Comment	: An internal comment, not shown to user
// axisLabelX	: text label
// axisLabelY	: text label
// flags	: int 128=hasIPC
// shortMulX	: int scale factor for X-axis; always 1
// shortUnitsX	: text units; always "s" for seconds
// thousandsX	: int multiplier; 1000 or 1024
// title	: diagram title, shown at top of Region 4
// tracebase	: text date and time of trace, yyyy-mm-dd_hh:mm:ss
//		  hh:mm:ss is back-converted to int and updated by X-scrolling
//		  both are shown at lower left of Region 5
// version	: version of the JSON data; should be 3 now
// events	: an array of 10-element arrays, one per timespan
//		  the last item is a dummy array with start time 999.0 so 
//		  that it sorts last, in order to avoid a comma after the last
//		  item, which would be a JSON syntax error.
//		  The design center is 1M events giving near-real-time
//		  pan, zoom, label, etc. Browser may run out of RAM before
//		  2M events though.
//
// event fields:
//  start time	: in seconds relative to hh:mm:00; expected 10ns resolution
//  duration	: in seconds; expected 10ns resolution
//  cpu		: int 0..
//  pid		: thread ID, often called PID in kernel source; 0 = idle
//  rpc		: RPC id that timespan is working on, or zero
//  ev		: event number, hex 000-fff for most events, 1xxxx for 
//		  user-mode execution to tid xxxx
//  arg0	: low 16 bits of first argument to syscall, else 0
//  ret		: low 16 bits of return value form syscall, else 0
//		  error returns -1..-128 show up as 65535..65408
//  ipc		: four-bit granular instructions per cycle, IPC
//  name	: text human-meaningful name for the timespan; syscall name, etc.
//
//============================================================================//

// Scrolling X-axis notes
//  The initial presentation of an input file shows the complete time range 
//  of the trace, up to 999 seconds (16+ minutes) and all 1M+ events.
//
//  Drawing 1M timespans is too slow to support real-time pan and zoom, and 
//  most of the timespans will be too small to see. So the redraw routine 
//  defers drawing spans shorter than one pixel until the accumulated size is 
//  at least a pixel, then draws a simplified representative line. This speeds
//  up redraw by 10x to 100x. As you zoom in, the full spans are revealed.
//
// Scrolling Y-axis notes
//  The Y-axis shows the input file timespans sorted by CPU number, by RPCID, 
//  by PID, and by busy resource. Each of these four groups can be expanded 
//  or suppressed.
// 
//  The initial presentation of an input file shows the complete range of
//  CPU numbers in the trace, but suppresses the other three groups. With
//  full expansion, there are potentially hundreds of thousands of timelines,
//  so the Y-axis also supports pan and zoom. 
//
//  Drawing 100K timelines is too slow to support real-time pan and zoom, and 
//  most of the timelines will be too small to see. So the redraw routine 
//  draws lines with a minimum height of one pixel, overlaying multiple 
//  timelines when more than one land on top of each other. The redraw
//  routine suppresses overlaid timespans unless they extend in time beyond 
//  the previously-drawn line's maximum time. This speeds up redraw by 10x 
//  or more with thousands of lines. As you zoom in, the full lines emerge.
//
// Timeline/text space notes
//  Timeline spacing runs from 2 pixels to 72 pixels. Within this, usually half
//  the vertical space is used to draw the timeline and half to draw text
//  annotations or marks. When the text half is smaller than the minimum
//  annotation text size of ~10px, maybe no text is drawn, or maybe one line.
//  As the text space increases, text size increases by perhaps 1/6 with
//  other 5/6 increasing whitespace until there is room for another line of
//  annotation/mark text.
//
// line spacing vs.overlay multiple timelines
// line/text split
// line drawing full vs abbreviation
// annotation/mark text size vs. multiple lines
// Y-label size vs. subsetting vs. overlay
//
// X-axis label extremes:
//  very big ~1000 seconds
//  very small ~10 nsec

// Y-axis extremes:
//  very big ~256K lines
//  very small ~4 lines
//
// Text-size notes
//  Four text sizes are used, and they dynamically adjust based on browser 
//  window size and user-selected multiplier: Title text, X-axis labels, Y-axis 
//  labels, and annotations/marks. The default text sizes scale linearly 
//  with the browser window height. In addition, a UI control can multiply the
//  text sizes uniformly by 0.75 1.00 1.25 or 1.50 
//  Multiplying by 1.25 or 1.50 shrinks number of annotation lines as needed
//  Multiplying by 0.75 shrinks text space, increases timespan height
//
// Default sizes: region 1 and hint, whatever HTML they are.
//   Title ~8%
//   Y-axis enough for 16-char names, or click-drag axis
//   IPC as today
//   X-axis enough for two lines ~8%
// Default scales:
//   Y-axis enough for just CPUs + 1.5
//   X-axis enough for entire trace timespan
//   (expanding groups does not change Y pan or zoom, but there is an 
//    extra line at bottom so expand last shows 1 line)

// notes: linewidth.k4=15 is readable, even with y-spacing of 8px. 
// could go down to k4=12. smalltick of 10 is readable, as is tile of 32, 
// tick of 14. vertical spacing went negative... Possibly can get by without d3.
// smalltick of 10 can multiply to 6.7, 10, 15, 20. This is on Mac with 4K
// monitor pretending to be 1000px high, not 2000. So 10px is actually 20px
// 8% top for label is good,10% too big
// winHeight 500 gives tick 18 x 2, so 7-8% bottom should do.
// line/text when 0.75 goes to 75-25 so if 60px as 30-30, goes to 45-15
//
// buttons: black text if available, gray if not; 
//  white w/gray outline if inactive, color w/color outline if active
// text boxes: white background if inactive, color if active
//
// CPU sort by number
// RPCID sort by start time
// resources sort by type/number
// PID sort by number
// Just do toggle @basetime for per-line zero-based, display as 00:00:00
//
// Special search syntax for all-caps CPUI CPUU CPUK RPC PID RES w/us..us
//   and highlight matching lines, not annotate spans
// make names l.c. use all-caps for totals; count is by line, not span
//
// Use same shift-click, shift-unshift convention for highlights as as 
// annotations -- obviousness
//
// search limited not only to onscreen by X, but also onscreen by Y
// including not looking at gray, so can selectively search just one cpu
//
// shift-click any @title text to rotate size
// shift-click any line label toggles highlight/not
//
// In general, click toggles, shift-click cycles (downward)
// CPU group: none,  highlight-only, show
// RPCID group: none,  highlight-only, show
// PID group: none,  highlight-only, show
// Resource group: none,  highlight-only, show
//
// BW: off/on
// IPC: off, user, kernel, both
// Marks: off, abc, d, both
// Annotate: off, spaced, all
// User-mode: off, first-one, spaced
// Title: text x 1.0 0.75 1.5 1.25
//
//============================================================================//
//
// state:
// X-axis scale/offset
// Y-axis scale/offset
// Bw int
// Ipc int, -1 if not available
// Marks int
// Annotate int
// User-mode int
// File text
// Search text
// search not
// search min/max usec float
// textsize multiplier int
// last selected span item#
// last highlighted line line# (bold?)
// CPU group int
// rpcid group int
// pid group int
// res group int
// Y-axis location int
//============================================================================//
//
// Upon loading json:
// move into data, remove any old data2/string to save space
// scan for min/max in each numeric field --
//  ts, dur, cpu, pid, rpc, ev, arg0, ret, ipc
// This allows setting initial scales and linecount
//  but for non-CPU linecount, need count of uniques, not min/max
//
// But also call new_windowsize function to read window size and set up region sizes
// and derive text and timespan line sizes 
// and backmap pixel size vs. time and pixelsize vs. line#
// if overlapping lines, count just once or at least map all the same
//
// Upon expanding a group:
// scan for unique values, sort, and map CPU/PID/RPC/RES to line numbers within group
// don't count non-highlight lines if not displayed
// reserve space for 4 group names when scaling lines numbers. hmm. 
// or backmap to 4x fraction of a line
// keep track of which lines are onscreen, preferably by simple min/max range
//

// Consider UI to keep track of N pan/zoom/option states, switch to any of them.
// perhaps 0-9, or A-Z; save/restore, or push/click to make pushed also top.
// shift-click-unshift to save, shift-click-unclick to erase, click to restore
// shift-click to save (turns bold), click to restore. restore saves current in 0
//
//============================================================================//




//----------------------------------------------------------------------------//
// Global constants                                                           //
//----------------------------------------------------------------------------//
 
// Dummy data to show when there is a missing file name
// 999.0 is end marker; will be popped off before use
var dummyData = {
  "axisLabelX" : " ",
  "axisLabelY" : " ",
  "shortMulX" : 1,
  "shortUnitsX" : "s",
  "thousandsX" : 1000,
  "title" : "File not found",
  "tracebase" : " ",
  "events" : [[0, 0, 0, 0, 0, 0, 0, 0, 0, "x"], 
              [999.0, 0, 0, 0, 0, 0, 0, 0, 0, "x"]]
};

// Little usage hints to display
var usage_text = "Scroll wheel to zoom. Click-drag to pan. " + 
  "Shift-click-unclick to annotate. " + 
  "Shift-click-unshift to annotate and keep. " + 
  "Shift-click-drag to measure. Red dot resets.";

var usage_text_empty = "";

// For buttons
var kActiveBackColor = "#F0F0FF";	// very light blue
var kActiveBorderColor = "#0000FF";	// blue
var kActiveTextColor = "#000080";	// dark blue

var kInactiveBackColor = "#FFFFFF";	// white
var kInactiveBorderColor = "#C0C0C0";	// light gray
var kInactiveTextColor = "#000000";	// black

var kUnuseableColor = "#E0E0E0";	// very light gray

var normalcolor = {
  color1: [
    "#CC0000", "#CC4700", "#CC8F00", "#BECC00", "#77CC00", 
    "#30CC00", "#00CC18", "#00CC5F", "#00CCA7", "#00A7CC", 
    "#005FCC", "#0018CC", "#3000CC", "#7700CC", "#BE00CC", 
    "#CC008F", "#CC0047" 
  ],

  color2: [
    "#FF0000", "#FF6600", "#FFCC00", "#CCFF00", "#66FF00", 
    "#00FF00", "#00FF66", "#00FFCC", "#00CCFF", "#0066FF", 
    "#0000FF", "#6600FF", "#CC00FF", "#FF00CC", "#FF0066" 
  ],

  gray1: [
//  color1: [
    "#959595", "#aeaeae", "#c8c8c8", "#dddddd", "#d5d5d5", 
    "#cecece", "#c9c9c9", "#cccccc", "#cecece", "#c2c2c2", 
    "#a8a8a8", "#8f8f8f", "#8c8c8c", "#939393", "#9b9b9b", 
    "#9a9a9a", "#989898"
//    "#2b2b2b", "#5e5e5e", "#919191", "#bababa", "#ababab", 
//    "#9c9c9c", "#939393", "#989898", "#9d9d9d", "#868686", 
//    "#525252", "#1f1f1f", "#181818", "#282828", "#373737", 
//    "#353535", "#303030"
  ],

  gray2: [
//  color2: [
    "#9b9b9b", "#bfbfbf", "#e3e3e3", "#f0f0f0", "#e5e5e5", 
    "#dadada", "#dedede", "#e2e2e2", "#d2d2d2", "#adadad", 
    "#898989", "#949494", "#9e9e9e", "#a2a2a2", "#9e9e9e" 
//    "#363636", "#7f7f7f", "#c8c8c8", "#e1e1e1", "#cccccc", 
//    "#b6b6b6", "#bdbdbd", "#c5c5c5", "#a4a4a4", "#5b5b5b", 
//    "#121212", "#282828", "#3d3d3d", "#454545", "#3d3d3d"
  ],

  mod1: 17,
  mod2: 15
};

// Experiment 2: rotate rgb colors to brg
var colorblindcolor = {
  color1: [
    "#00CC00", "#00CC47", "#00CC8F", "#00BECC", "#0077CC", 
    "#0030CC", "#1800CC", "#5F00CC", "#A700CC", "#CC00A7", 
    "#CC005F", "#CC0018", "#CC3000", "#CC7700", "#CCBE00", 
    "#8FCC00", "#47CC00" 
  ],

  color2: [
    "#00FF00", "#00FF66", "#00FFCC", "#00CCFF", "#0066FF", 
    "#0000FF", "#6600FF", "#CC00FF", "#FF00CC", "#FF0066", 
    "#FF0000", "#FF6600", "#FFCC00", "#CCFF00", "#66FF00" 
  ],

  gray1: [
    "#959595", "#aeaeae", "#c8c8c8", "#dddddd", "#d5d5d5", 
    "#cecece", "#c9c9c9", "#cccccc", "#cecece", "#c2c2c2", 
    "#a8a8a8", "#8f8f8f", "#8c8c8c", "#939393", "#9b9b9b", 
    "#9a9a9a", "#989898"
  ],

  gray2: [
    "#9b9b9b", "#bfbfbf", "#e3e3e3", "#f0f0f0", "#e5e5e5", 
    "#dadada", "#dedede", "#e2e2e2", "#d2d2d2", "#adadad", 
    "#898989", "#949494", "#9e9e9e", "#a2a2a2", "#9e9e9e" 
  ],

  mod1: 17,
  mod2: 15
};



// HSB(n mod 17, 1.0, 0.8)  top/middle, no white
var color17 = [
  "#CC0000", "#CC4700", "#CC8F00", "#BECC00", "#77CC00", 
  "#30CC00", "#00CC18", "#00CC5F", "#00CCA7", "#00A7CC", 
  "#005FCC", "#0018CC", "#3000CC", "#7700CC", "#BE00CC", 
  "#CC008F", "#CC0047", 
];

// HSB(n mod 15, 1, 1)  bottom/outer, no white
var color15 = [
  "#FF0000", "#FF6600", "#FFCC00", "#CCFF00", "#66FF00", 
  "#00FF00", "#00FF66", "#00FFCC", "#00CCFF", "#0066FF", 
  "#0000FF", "#6600FF", "#CC00FF", "#FF00CC", "#FF0066", 
];


// unknown: light yellow, fault: light red, interrupt: light blue, syscall: light green
var kernelcolor = [
  "#FFFFE0", "#FFFFE0", "#FFFFE0", "#FFFFE0", 
  "#FFC0C0", "#C0C0FF", "#FFC0C0", "#C0C0FF",  
  "#E0FFE0", "#E0FFE0", "#E0FFE0", "#E0FFE0", 
  "#E0FFE0", "#E0FFE0", "#E0FFE0", "#E0FFE0", 
  ];

var kernelgray = [
//var kernelcolor = [
  "#fdfdfd", "#fdfdfd", "#fdfdfd", "#fdfdfd", 
  "#e6e6e6", "#e2e2e2", "#e6e6e6", "#e2e2e2", 
  "#fafafa", "#fafafa", "#fafafa", "#fafafa", 
  "#fafafa", "#fafafa", "#fafafa", "#fafafa" 

//  "#fcfcfc", "#fcfcfc", "#fcfcfc", "#fcfcfc", 
//  "#cdcdcd", "#c4c4c4", "#cdcdcd", "#c4c4c4", 
//  "#f6f6f6", "#f6f6f6", "#f6f6f6", "#f6f6f6", 
//  "#f6f6f6", "#f6f6f6", "#f6f6f6", "#f6f6f6"
  ];

 

// unknown:  yellow, fault:  red, interrupt:  blue, syscall:  green
var darkkernelcolor = [
  "#FFFF70", "#FFFF70", "#FFFF70", "#FFFF70", 
  "#FF6060", "#6060FF", "#FF6060", "#6060FF",  
  "#70FF70", "#70FF70", "#70FF70", "#70FF70", 
  "#70FF70", "#70FF70", "#70FF70", "#70FF70", 
  ];

var darkkernelgray = [
//var darkkernelcolor = [
 "#f9f9f9", "#f9f9f9", "#f9f9f9", "#f9f9f9", 
  "#c0c0c0", "#b5b5b5", "#c0c0c0", "#b5b5b5", 
  "#eaeaea", "#eaeaea", "#eaeaea", "#eaeaea", 
  "#eaeaea", "#eaeaea", "#eaeaea", "#eaeaea" 

//  "#f4f4f4", "#f4f4f4", "#f4f4f4", "#f4f4f4", 
//  "#818181", "#6b6b6b", "#818181", "#6b6b6b", 
//  "#d6d6d6", "#d6d6d6", "#d6d6d6", "#d6d6d6", 
//  "#d6d6d6", "#d6d6d6", "#d6d6d6", "#d6d6d6" 
  ];

var prefixCpu = 0;
var prefixPid = 1;
var prefixRpc = 2;
var prefixRes = 3;

var textmultiplier_tbl = [1.0, 0.75, 1.5, 1.25];

var kFromBase40 = "_abcdefghijklmnopqrstuvwxyz0123456789-./";

var ipctextoffset = [0, 0, 4, 8];



// Set the initial margins of the graph
var margin = {top: 20, right: 20, bottom: 50, left: 70, diagramtop: 20, diagrambottom: 50};
 
// Set the margins of the SVG area
var winMargin = {width: 10, height: 40};	// Room for borders and File: box

// Room for top/bottom HTML. These fit snuggly for Chrome, but run over for Safari
// Altered in initializeState if needed
var winMargin2 = {top:40, top2x: 60, bottom:50, bottom2x: 70, left:15, right:15, width1: 1100};	


// Click to toggle 0/max
// Shift-click to cycle 0 max max-1 ... 0
var cb_value_max = 1;			// 0: normal colors, 1: color-blind colors
var ipc_value_max = 3;			// 0: none, 1: kernel, 2: user, 3: all
var marks_value_max = 3;		// 0: none, 1: number, 2: text, 3: all
var arcs_value_max = 1;			// 0: none, 1: all
var annotateall_value_max = 1;		// 0: none, 1: all
var annotateuser_value_max = 1;		// 0: none, 1: all
var searchnot_value_max = 1;		// 0: normal, 1: invert match         
var textmultiplier_value_max = 3;	// 0: normal, 1: 0.75x, 2: 1.5x, 3: 1.25x
var basetime0_value_max = 1;		// 0: normal, 1: relative to start
var compress_value_max = 3;		// 0: none, 1: gray0.1, 2: gray0.2, 3: all

var axesmargin = 5;	// Pixels. Keep axes and pan zoom rect away from region3 edges

// Annotates: possibly cycle thru long vs. short annotations

// Note: highlighting is shift-click, because it is in the zoom/pan click area
// Behaves like shift-click to annotate

// Region 0 is HTML above the svg. see winMaergin2.top
// Region 1 is the top part of svg for title
// Region 2 is the left part of svg for Y-axis labels
// Region 3 is the middle part and holds all the timelines
// Region 4 is the optional IPC legend
// Region 5 is two-line X-axis
// Region 6 is HTML below the SVG. see winMargin2.bottom

// Each region has a percentage of the outersvg width/height, with min and max bounds
var region1paramH = [8, 20, 80];		// Title gets 8% of height
var region5paramH = [8, 20, 80];		// X-axis and footer gets 8% of height
// Middle gets the rest ~= 84% of height

var region2paramW = [12, 50, 150];	// Y-axis gets 12% of width
var region4paramW = [8, 40, 80];	// IPC legend gets 8% of width
// Timelines get the rest ~= 80% of width

var ipcvalues = ["0", "1/8", "1/4", "3/8",  "1/2", "5/8", "3/4", "7/8", 
                 "1.0", "1.25", "1.5", "1.75",  "2.0", "2.5", "3.0", "3.5"];
var ipc_color = ["#555555", "#0000FF", "#0000FF", "#AA0000"]; 
//         dark gray < 1/2    1/2 <= blue < 2     dark red >= 2

// Non-Highlighted items are displayed in gray, highlighted in color
// Heights vary by group compress value
var grayHeight = [0, 1, 5, 20];	// Subscripted by compress_xxx 
var maxTrackHeight = 20;

//----------------------------------------------------------------------------//
// Globals about browser window and allocated SVG                             //
//----------------------------------------------------------------------------//

var winTileHeight;
var winTileWidth;
var winScale;

var winWidth = 960;	// Default 16:9, immediately overwritten
var winHeight = 540;
var svgWidth = 16;	// Default, immediately overwritten
var svgHeight = 9;

var region1height, region234height, region5height;
var region2width, region3width, region3clipwidth, region4width;

var outersvg, svgdotg, innersvg, innersvgdotg;
var region2, region2dotg;
var reddot;


//----------------------------------------------------------------------------//
// Globals for X-axis                                                         //
//----------------------------------------------------------------------------//
var axisTickPx = "16px";
var AxisLabelPx = "20px";
var titlePx = "32px";

// Scales for the axes
var x;
var x_zoomed;

// The axis definitions
var xAxis;

// The groups containing the drawn axis and vertical grid overlay
var gXgrid;
var gX;

// The svg zoom, no attach, no draw; define watcher
var myZoom_x;
var panzoomrect_x = null;


// leftmost and rightmost on-screen x values, for filtering, for speed
var realxleft;
var realxright;
var realxrightmost;	  // includes the margin.right padding
var xdomainwidth;	  // abs(right - left)
var arcfraction = 0.05;   // What fraction of window width to draw an arc
var xpixelfraction = 1.0;  // What fraction of a pixel width to do full draw
var xsecperpix = 0;	  // Only do full drawing of items >= xsecperpix
 
var xaxisfmt = {
  basetime: 0,
  deltamul: 1, 
  deltamax: 1000, 
  ovflnext: 0, 
  ovflformat: "03.0f",
  deltaformat: "03.0f"
};


//----------------------------------------------------------------------------//
// Globals for Y-axis                                                         //
//----------------------------------------------------------------------------//

// Scales for the axes
var y;
var y_zoomed;

// The axis definitions
var yAxis;

// The groups containing the drawn axis
var gY;

// The svg zoom, no attach, no draw; define watcher
var myZoom_y;
var panzoomrect_y = null;


// topmost and bottommost on-screen y values (tracks), for filtering, for speed
var realytop;
var realybottom;
var ydomainwidth;	  // abs(top - bottom)
var ypixelfraction = 1.0;  // What fraction of a pixel width to do full draw
var ypixpertrack = 0;	  // Only do full drawing of items >= ypixpertrack

// Within-track event and annotation positions and sizes, for each of
// track sizes 1..20. Function of Y-axis zoom
//  perTracksize[i].annotsize 	annotation font size in pix
//  perTracksize[i].annotcount 	annotation lines of text for this size
//                              = trunc(annotheight / annotsize)
//  perTracksize[i].eventheight pix height for drawing events
//  perTracksize[i].annotheight pix height for drawing annotation text
//  perTracksize[i].eventoffset pix offset for event centerline
//  perTracksize[i].annotoffset pix offset for annot[0] text baseline
 
var perTracksize = [];


//----------------------------------------------------------------------------//
// Globals for data and its metadata                                          //
//----------------------------------------------------------------------------//
var data = null;
var eventToRow = [];	// Map events to sorted rows. Will be 4 x 64K

// All these will be number of rows in size
var sortNum = [];		// Gives grouped event number for each row
var sortName = [];		// Gives grouped event name for each row
var rowToMinT = [];
var rowToMaxT = [];
var rowToHeight = [];		// Per row, N+1 rows
var rowToTrack = [];		// Per row, N+1 rows
var rowToHighlighted = [];	

var dataTsLo, dataTsHi;
var dataBaseDate, dataBaseSecond;

var sortNum_cpu_start = 0;
var sortNum_pid_start = 0;
var sortNum_rpc_start = 0;
var sortNum_res_start = 0;
var sortNumSize = 0;		// Number of rows
var maxTrack = 0;		// Current Number of tracks

//----------------------------------------------------------------------------//
// Globals for drawing                                                        //
//----------------------------------------------------------------------------//

// These hold per-row state while drawing events
// All are subscripted by row number
var defer_dur_i = [];		// Idle
var defer_dur_u = [];		// User
var defer_dur_k = [];		// Kernel
var defer_dur = [];		// All -- nothing lost
var defer_event_u = [];		// Most recent deferred user event
var defer_event_k = [];		// Most recent deferred kernel event
var highwater_mark = [];
var rowToLabelk = [];		// Rotate event labels separately for each row
var rightmostnum = [];		// Spread apart mark_d numbers
// TODO: change to rightmostlabel and use for annots also ??
//  or separate var to deal with not too many per x-pixel

 
//----------------------------------------------------------------------------//
// Global UI state                                                            //
//----------------------------------------------------------------------------//

// Update initializeState() if you add/subtract anything here
var state = {
  filename_text: "", 
  currentcolor: normalcolor,
  cb_value: 0, 			// do not show IPC by default
  ipc_value: 0, 		// do not show IPC by default
  marks_value: 3, 		// Initially, show all marks
  arcs_value: 1, 		// Initially, show all arcs (when zoomed in enough)
  annotateall_value: 0, 	// Off
  annotateuser_value: 0, 	// Off
  searchnot_value: 0,		// false = like grep. true = like grep -v
  search_text: "",
  usec_lo_text: "",
  usec_hi_text: "",
  textmultiplier_value: 0,
  basetime0_value: 0,

  // For the four groups: Cpu, Pid, Rpc, Res(ource)
  grouplength: [0, 0, 0, 0],
  groupcompress: [3, 0, 0, 0], 		// Show CPUs, collapse others
  grouplabelypos: [0, 0, 0, 0],		// In pixels, for expand/compress place 
  groupfirsttrack: [0, 0, 0, 0], 	// Label track number for expand/compress place

  // X-axis and Y-axis scaling
  savedtransformX: d3.zoomIdentity,
  savedtransformY: d3.zoomIdentity,

  // Highlighted events and their rows
  hilite_event_set: new Set(),
  hilite_row_set: new Set(),
  fullsize_row_set: new Set(),		// has at least one highlighted event

  // NOTE: save/restore does not work for sets. Sigh.
  // So instead we move sets into these arrays around save/restore
  hilite_event_array: [],
  hilite_row_array: [],
  fullsize_row_array: [],

  // List of items that are annotated on screen
  annotated_d: [],

  // Single item annotated even across pan/zoom
  annotated_one_d: -1,

  dummy_placeholder: 0		// No comma here
};



// Saving state N copies current to [N]
// Restoring state N copies current to [0] and loads current from [N]
//  (swaps cleanly if N=0)
var savedstate = [{}, {}, {}, {}, {}, {}];	// [0]..[5]
var saved_valid = [false, false, false, false, false, false];

var more_text = false;


//----------------------------------------------------------------------------//
// Other globals                                                              //
//----------------------------------------------------------------------------//

// Set the initial sizes of text
var textsize = {tick: 16, smalltick: 12, label: 20, title: 32, annot: 12};

// Set the initial sizes of event lines
var linewidth = {
  k4 : 30, k3 : 28, k2 : 16, k1 : 6,  
  idle : 2, u2 : 12, u1 : 8
};

// Set the initial dimensions of the graph by calling resize()
var width;
var height;
//var region234height;	// Smaller than height if not many tracks
 

// LOCAL For rubberband
var rubberband;		// Below marked object
var rubberband2;	// Above marked object
var rubberband3;	// Time between two objects
var rubberband4;	// background for rubberband3 text
var x1, y1;
var dx1, dy1;
var vx1, vx2;
var mx1, my1;
var d1, d2;		// First and second marked data objects


// LOCAL For first-seen user-mode annotation 
var dont_annotate = [];
dont_annotate[0x10000] = true;	// Never label -idle- event

// LOCAL For annotations


//VERYTEMP -------------------------------------------------
function makecolors() {
var foobar = "";
// Turn hex color "#rrggbb" string into grayscale one
function togray(str) {
  var rr = parseInt(str.substr(1,2), 16);
  var gg = parseInt(str.substr(3,2), 16);
  var bb = parseInt(str.substr(5,2), 16);
  // sRGB luminance
  var yy = 0.213 * rr + 0.715 * gg + 0.072 * bb;
  var yyhex = (yy + 0x100).toString(16).substr(1,2);  
  var strgray = '"#' + yyhex + yyhex + yyhex + '", ';
//console.log(str, strgray);
  foobar += strgray;
}

function lighten(str) {
  var rr = parseInt(str.substr(1,2), 16);
  var gg = parseInt(str.substr(3,2), 16);
  var bb = parseInt(str.substr(5,2), 16);
  rr = Math.floor(128 + (rr / 2));
  gg = Math.floor(128 + (gg / 2));
  bb = Math.floor(128 + (bb / 2));
  var rrhex = (rr + 0x100).toString(16).substr(1,2);  
  var gghex = (gg + 0x100).toString(16).substr(1,2);  
  var bbhex = (bb + 0x100).toString(16).substr(1,2);  

  var strlight = '#' + rrhex + gghex + bbhex;
//console.log("strlight", strlight);
  return strlight;
}

function darken(str) {
  var rr = parseInt(str.substr(1,2), 16);
  var gg = parseInt(str.substr(3,2), 16);
  var bb = parseInt(str.substr(5,2), 16);
  rr = Math.floor((rr * 3) / 4);
  gg = Math.floor((gg * 3) / 4);
  bb = Math.floor((bb * 3) / 4);
  var rrhex = (rr + 0x100).toString(16).substr(1,2);  
  var gghex = (gg + 0x100).toString(16).substr(1,2);  
  var bbhex = (bb + 0x100).toString(16).substr(1,2);  

  var strdark = '#' + rrhex + gghex + bbhex;
//console.log("strdark", strdark);
  return strdark;
}

foobar = "";
foobar += "color1\n";
for (var i = 0; i < normalcolor.mod1; ++i) {
  togray(lighten(normalcolor.color1[i]));
}
foobar += "\n";
foobar += "color2\n";
for (var i = 0; i < normalcolor.mod2; ++i) {
  togray(lighten(normalcolor.color2[i]));
}
foobar += "\n";
foobar += "cbcolor1\n";
for (var i = 0; i < colorblindcolor.mod1; ++i) {
  togray(lighten(colorblindcolor.color1[i]));
}
foobar += "\n";

foobar += "cbcolor2\n";
for (var i = 0; i < colorblindcolor.mod2; ++i) {
  foobar += darken(colorblindcolor.color2[i]) + ", ";
}
foobar += "\n";

foobar += "cbcolor2\n";
for (var i = 0; i < colorblindcolor.mod2; ++i) {
  togray(lighten(darken(colorblindcolor.color2[i])));
}
foobar += "\n";
foobar += "\n";

foobar += "kernel\n";
for (var i = 0; i < 16; ++i) {
  togray(lighten(kernelcolor[i]));
}
foobar += "\n";
foobar += "darkkernel\n";
for (var i = 0; i < 16; ++i) {
  togray(lighten(darkkernelcolor[i]));
}
foobar += "\n";

foobar += "other\n";
togray(lighten("#C00000")) ;
togray(lighten("#000000")) ;
foobar += "\n";

console.log(foobar);
}

//makecolors();
// end VERYTEMP -------------------------------------------------



//----------------------------------------------------------------------------//
// Function definitions                                                       //
//----------------------------------------------------------------------------//

// Gets the browser name or returns an empty string if unknown.
// navigator.userAgent
// Chrome
// "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
// Safari
// "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.2 Safari/605.1.15" = $1 
// Firefox
// "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:64.0) Gecko/20100101 Firefox/64.0"


function whichBrowser() {
  // Order is important here. Otherwise, Chrome reports as Safari.
  if (navigator.userAgent.indexOf(' Chrome') >= 0) {return 'Chrome';}
  if (navigator.userAgent.indexOf(' Safari') >= 0) {return 'Safari';}
  if (navigator.userAgent.indexOf(' Firefox') >= 0) {return 'Firefox';}

    // Opera 8.0+
    var isOpera = (!!window.opr && !!opr.addons) || 
      !!window.opera || 
      navigator.userAgent.indexOf(' OPR/') >= 0;

    // Firefox 1.0+
    var isFirefox = typeof InstallTrigger !== 'undefined';

    // Safari 3.0+ "[object HTMLElementConstructor]" 
    var isSafari = /constructor/i.test(window.HTMLElement) || 
      (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })
       (!window['safari'] || safari.pushNotification);

    // Internet Explorer 6-11
    var isIE = /*@cc_on!@*/false || !!document.documentMode;

    // Edge 20+
    var isEdge = !isIE && !!window.StyleMedia;

    // Chrome 1+
    var isChrome = !!window.chrome;

    // Blink engine detection
    var isBlink = (isChrome || isOpera) && !!window.CSS;

    var foo = 
        isOpera ? 'Opera' :
        isFirefox ? 'Firefox' :
        isSafari ? 'Safari' :
        isChrome ? 'Chrome' :
        isIE ? 'IE' :
        isEdge ? 'Edge' :
        isBlink ? 'Blink' :
        "Don't know";
    return foo;
};

// Just look at start time of each item in annotated_d
function FindNearestAnnotated(t) {  
  var nearest = -1;
  var nearestdist = 0;
  // Ignore y for a match, ignore duration  
//console.log("annotated_d.length=", state.annotated_d.length);
  for (j = 0; j < state.annotated_d.length; ++j) {
    var i = state.annotated_d[j];
    var d = data.events[i];
    var dist = Math.abs(ts(d) - t);
//console.log("  ", i, ts(d), t, dist); 
    if ((nearest < 0) || (dist < nearestdist)) {
      nearest = i;
      nearestdist = dist;
    }
  }
//console.log("  =", nearest); 
  return nearest;
}


function initializeState() {
console.log("initializeState");
  state.filename_text = "";
  state.cb_value = 0;
  state.ipc_value = 0;
  state.marks_value = 3;
  state.arcs_value = 1;
  state.annotateall_value = 0;
  state.annotateuser_value = 0;
  state.searchnot_value = 0;
  state.search_text = "";
  state.usec_lo_text = "";
  state.usec_hi_text = "";
  state.textmultiplier_value = 0;
  state.basetime0_value = 0;

  state.groupcompress = [3, 0, 0, 0];	// Show CPUs, collapse others
  state.grouplabelypos = [0, 0, 0, 0],	// In pixels 
  state.groupfirsttrack = [0, 0, 0, 0],	// Label track number  

  state.savedtransformX = d3.zoomIdentity;
  state.savedtransformY = d3.zoomIdentity;

  state.hilite_event_set.clear();
  state.hilite_row_set.clear();
  state.fullsize_row_set.clear();

  state.hilite_event_array = [];
  state.hilite_row_array = [];
  state.fullsize_row_array = [];

  state.annotated_d = [];
  state.annotated_one_d = -1;
  //---------------------------- end init of state

  // Saved states become invalid with new data
  savedstate = [{}, {}, {}, {}, {}, {}];	// [0]..[5]
  saved_valid = [false, false, false, false, false, false];

  more_text = false;
  document.getElementById("moretext").style.display = "none";


  // Set up extra margin space within window for some browsers
  var thisbrowser = whichBrowser();
console.log("browser:", thisbrowser);
  if (thisbrowser == "Chrome") {
    winMargin2 = {top:40, top2x: 60, bottom:50, bottom2x: 70, 
                  left:15, right:15, width1: 1100};	
  }
  if (thisbrowser == "Safari") {
    winMargin2 = {top:40, top2x: 80, bottom:50, bottom2x: 80, 
                  left:20, right:20, width1:1400};	
  }
  if (thisbrowser == "Firefox") {
    winMargin2 = {top:40, top2x: 80, bottom:50, bottom2x: 80, 
                  left:20, right:20, width1:950};	
  }


  // TODO: Add idle, idle_low_power, c_exit
  // TODO: get all the magic numbers put for events
  // TODO: get all th magic numbers out for colors

  // TODO: revisit gray line positioning scroll

  // TODO: low water mark in showing Y-labels
  // TODO: update annotateall use to make min_ts be per row
  // TODO: update annotateuser use to make min_ts be per row 
  // TODO: update annotateuser use to repeat after loose high-water 
  // TODO: give some visual hint when mouseover active but non-obvious click zone
  //       maybe a partly-transparent bluish oval on mouseover




  //DONE TODO: pan sets wrong-row single annot
  //DONE TODO: click and shift-click on title should not set single annot
  //DONE TODO: add 1-pix-wide accumulate X-direction
  //  add 1-pix-high Y-direction: just draw kernel/user
  //  if width ~1px, draw single color/gray
  //DONE TODO: add thin Y-direction
  //  if height < ~5px, draw single color/gray
  //DONE TODO: if gray, drop all annotation, marks, etc. keep sine waves as gray
  //  Make idle and sine wave gray
  //  Fix height[0]
  //DONE TODO: bold originally-highlited rows
  //DONE TODO:
  //  capture color/gray, ipc_k, ipc_u, ipc_i, mark_abc, mark_d
  //  capture full/small in X direction, full/small in Y direction
  //DONE TODO: revisit deciding gray row once vs. on-the-fly what is currently on screen
  //DONE TODO: change design for highlights to do entire clicked row, bold label, plus
  //       show kernel/user in color on other rows
  //
  // Design: highlight a row shows it in color and its kernel/user in color on other rows
  //  this covers all events in that row, not just those onscreen.
  //  all other rows are marked to show full height even though they contain some gray
  //  shift-click to add a highlighted row simply adds to colored events and to
  //  full-height rows.
  //  nothing special happens for search, annotate, etc.
  //  no events are deleted in any rows, just their colors change -- maybe
  //  a given row can be on one of several states:
  //  - normal, no rows highlighted. all rows in full-height color
  //  - highlighted row. all events in full-height color
  //    row label is shown in bold
  //  - non-highlighted row with some highlighted events. full height, mixed color/gray
  //    (highlighted events might be offscreen)
  //  - non-highlighted row with no highlighted events. partial height all gray.
  //  This last, only, might be better done with no annotes, no markers, and no ipc,
// 2019.01.31
  //DONE TODO: reconnect fast draw
  //DONE TODO: shift-click select should go to front, only moving left
  //DONE TODO: Draw thin rows in just one color, like narrow events
  //DONE TODO: drag turns off annotate all/user
  //DONE TODO: draw ipc when drawing event
  //DONE TODO: draw marks when drawing events
  //DONE TODO: gray out pid, etc. when count is zero
// 2019.01.27
  //DONE TODO: reinstate annotated_one_d
  //DONE TODO: last_annotated, set of highlighted events
  //DONE TODO: add [more] text
  //DONE TODO: draw annotation text
  //DONE TODO: toggle annotation all/user to erase previous, other, show button
  //DONE TODO: rethink annotation text -- at least one line, white underlay
  //DONE TODO: connect up user annots
  //DONE TODO: connect up all annots
  //DONE TODO: connect up search annots
  //DONE TODO: clean up widths
  //DONE TODO: connect up single annots
  //DONE TODO: remove rgba in favor of opacity
  //DONE TODO: remove yellow outer background
  //DONE TODO: get gimp to use svg width/height
  //DONE TODO: move circled text
  //DONE TODO: make gray lighter
  //DONE TODO: scroll bars came back
  //DONE TODO: sine wave is too tall when shrunk
  //DONE make sure save/restore works
  //DONE TODO: implement highlighting
  //DONE TODO: implement gray for non-highlights
  //DONE TODO: Fix y-coordinate on shift-click annotations
  //DONE TODO: build back-up from Y-pixel to track to row, for mapping
  //DONE       click to which row to highlight
  //DONE TODO: have top line on screen not move when expand/contract, auto-prune, etc.
  //DONE       (involves adjusting Y-pan, possibly keeping k constant)
// 2019.01.01
  //DONE TODO: draw a Y-axis line; offset text left
  //DONE TODO: implement group expand/contract
  //DONE TODO: implement sine wave
  //DONE TODO: implement y-axis labels
  //DONE TODO: implement y-axis pan/zoom
  //DONE TODO: fix line widths
  //DONE TODO: make tick text noselect
  //DONE TODO: x-axis scale, y-axis scale, 
  //DONE TODO: make save/restore work on scales
  //DONE TODO: draw events
  //DONE TODO: pan/zoom Y on Region2
  //DONE TODO: call updateTracks when Y-axis groups expand/contract or highlights change
  //DONE TODO: also call updateTracks when X-axis scrolls


}



// Accessor functions for 10-element events
// ts           dur       CPU tid  rpc event arg0 ret ipc  name
function ts(d)  {return d[0];}
function tsrel(d)  {return d[0] - xaxisfmt.basetime;}		// Relative to basetime
function tsrel_0(d)  {return d[0] - xaxisfmt.basetime;}	// Relative to rowToMinT
function dur(d) {return d[1];}
function cpu(d) {return d[2];}
function pid(d) {return d[3];}	// Actually thread ID, but called pid in kernel
function tid(d) {return d[3];}
function rpc(d) {return d[4];}
function ev(d)  {return d[5];}
function arg0(d) {return d[6];}
function cpu2(d) {return d[6];}
function ret(d) {return d[7];}
function ipc(d) {return d[8];}
function name(d) {return d[9];}
// placeholder for now
function res(d) {return -1;}

function tsend(d) {return d[0] + d[1];}
function tsrelend(d) {return (d[0] - xaxisfmt.basetime) + d[1];}

function set_ts(d, v) {d[0] = v;}
function set_dur(d, v) {d[1] = v;}
function set_ev(d, v) {d[5] = v;}


// Boolean functions to decompose events
function is_idle(d)    {return ev(d) == 0x10000;}
function is_c_exit(d)    {return ev(d) == 0x20000;}
function is_special(d) {return (ev(d) & 0xffff0) == 0x00200;}
function is_mark(d) {return (0x020A <= ev(d)) && (ev(d) <= 0x020D);}
function is_kernel(d)  {return (ev(d) & 0xff000) == 0x00000 && !is_special(d);}
function is_fault(d)   {return (ev(d) & 0xfff00) == 0x00400;}  
function is_irq(d)     {return (ev(d) & 0xfff00) == 0x00500;}  
function is_syscall(d) {return (ev(d) & 0xffe00) == 0x00800;}  
function is_user(d)    {return (ev(d) & 0xf0000) == 0x10000 && !is_idle(d);}
function is_useroridle(d)    {return (ev(d) & 0xf0000) == 0x10000;}
function is_kerneloruser(d)  {return is_kernel(d) || is_user(d);}
function is_kernelusermark(d)  {return is_kernel(d) || is_user(d) || is_mark(d);}

function is_bottom_half(d)  {return ev(d) == 0x5FF;}
function is_sched_syscall(d) {return ev(d) == 0x009FF;}  


// Overlays are manually added markup
// Except arcs are becoming first-class citizens 2019.03.11
function is_bracket(d) {return ev(d) == -1;}
function is_oval(d) {return ev(d) == -2;}
function is_arc(d) {return ev(d) == -3;}
function is_overlay(d) {return (ev(d) < 0) && !is_arc(d);}
function is_any_overlay(d) {return (ev(d) < 0);}

 
function is_idle_ev(ev)    {return ev == 0x10000;}
function is_c_exit_ev(ev)    {return ev == 0x20000;}
function is_special_ev(ev) {return (ev & 0xffff0) == 0x00200;}
function is_mark_ev(ev) {return (0x020A <= ev) && (ev <= 0x020D);}
function is_kernel_ev(ev)  {return (ev & 0xff000) == 0x00000 && !is_special_ev(ev);}
function is_fault_ev(ev)   {return (ev & 0xfff00) == 0x00400;}  
function is_irq_ev(ev)     {return (ev & 0xfff00) == 0x00500;}  
function is_syscall_ev(ev) {return (ev & 0xffe00) == 0x00800;}  
function is_user_ev(ev)    {return (ev & 0xf0000) == 0x10000 && !is_idle_ev(ev);}
function is_useroridle_ev(ev)   {return (ev & 0xf0000) == 0x10000;}
function is_kerneloruser_ev(ev) {return is_kernel_ev(ev) || is_user_ev(ev);}
function is_kernelusermark_ev(ev) {return is_kernel_ev(ev) || is_user_ev(ev) || is_mark_ev(ev);}

function is_bottom_half_ev(ev)  {return ev == 0x5FF;}

function is_bracket_ev(ev) {return ev == -1;}
function is_oval_ev(ev) {return ev == -2;}
function is_arc_ev(ev) {return ev == -3;}
function is_overlay_ev(ev) {return (ev < 0) && !is_arc_ev(ev);}
function is_any_overlay_ev(ev) {return (ev < 0);}



// Function to parse the date / time
var parseTime = d3.timeParse("%d-%b-%y");
 
 
 
// Watcher for mouse wheel, mouse pan within svgdotg
// When activated, changes translate/scale of view (which changes drawing), 
// resets scales x and y, reattaches to xAxis and yAxis, redraws groups gX and 
 
// Forward map pre-zoomed pixels to pan/zoom client pixels
function panzoomX(x, transform) {
  return ((x * transform.k + transform.x));
}
function panzoomY(y, transform) {
  return ((y * transform.k + transform.y));
}
 
// Backmap mouse client pixels to pre-zoomed pixels
function panzoomInvertX(x, transform) {
  return ((x - transform.x) / transform.k);
}
function panzoomInvertY(y, transform) {
  return ((y - transform.y) / transform.k);
}
 
// x in seconds to h:m:ss.fraction
// pass in secfmt = "02d" or "06.3f" or "09.6f" sec/msec/usec
function hhmmss(x, secfmt) {
  var xt = Math.trunc(x);			// Integer seconds
  var hh = Math.trunc(xt / 3600) % 60;
  var mm = Math.trunc(xt / 60) % 60;
  // var ss =  Math.trunc(xt) % 60; 
  var xfsec = x - (hh * 3600) - (mm * 60);
  return d3.format("02d")(hh) + ":" + 
    d3.format("02d")(mm) + ":" + 
    d3.format(secfmt)(xfsec);
}
 
// Fancier thousands scaling, 3 digits
function shortnum(x, thousands) {
  var x0 = x;
  var k = 0;
  if (x == 0) {return d3.format(".0f")(x);}
  while (Math.abs(x0) >= thousands && k < 4) {x0 = x0 / thousands; k = k + 1;}
  while (Math.abs(x0) < 1 && k > -4) {x0 = x0 * thousands; k = k - 1;}
  // Now we have 1 <= x0 < thousands (which is expected to be 1000 or 1024),
  // if between roughly 10**-12 and 10**12
  var fmt = ".0f";
  if (x0 < 99.99) {fmt = ".1f";}
  if (x0 < 9.999) {fmt = ".2f";}
  if (x0 < 0.9999) {fmt = ".3f";}
  // Note space if no units scaling letter
  return d3.format(fmt)(x0) + "pnum KMGT"[k+4];
}

// Self-contained thousands scaling, 5 digits of time
function shortnum5(x) {
  var x0 = x;
  var k = 0;
  if (x <= 0) {return d3.format(".0f")(x);}
  while (Math.abs(x0) >= (2000) && k < 4) {x0 = x0 / 1000; k = k + 1;}
  while (Math.abs(x0) < 2 && k > -4) {x0 = x0 * 1000; k = k - 1;}
  // Now we have 2 <= x0 < 2000 
  var fmt = ".1f";
  if (x0 < 999.9) {fmt = ".2f";}
  if (x0 < 99.99) {fmt = ".3f";}
  if (x0 < 9.999) {fmt = ".4f";}
  // Note space if no units scaling letter
  return d3.format(fmt)(x0) + "pnum KMGT"[k+4] + "s";
}

// Input is a ts in seconds for labelling an X-axis tic mark
// Uses global basetime and xaxisfmt 
// Formats the delta from basetime
function shortxtime(x) {
//console.log("shortxtime", x, xaxisfmt);
  if (xaxisfmt.deltamul == 0) {
    // Turn seconds into hh:mm
    var delta = Rnd0(x - xaxisfmt.basetime);
    var mm = Math.trunc(delta / 60);
    var ss = Math.trunc(delta) % 60;
    return (showovfl ? d3.format(xaxisfmt.ovflformat)(xaxisfmt.ovflnext) + ":" : "") + 
      d3.format("02d")(mm) + ":" + d3.format("02d")(ss);
  }
  var delta = Rnd1((x - xaxisfmt.basetime) * xaxisfmt.deltamul);
  var showovfl = (xaxisfmt.deltamax == delta);
  if (xaxisfmt.deltamax <= delta) {delta -= xaxisfmt.deltamax;}
  return (showovfl ? d3.format(xaxisfmt.ovflformat)(xaxisfmt.ovflnext) + "_" : "") + 
    d3.format(xaxisfmt.deltaformat)(delta);
}
 

// Reset rotating label positions per row
function resetRotatingLabelk() {
  for (var i = 0; i < sortNumSize; ++i) {rowToLabelk[i] = 0;}
}

function resetlines() {
  d3.selectAll(".verticalline").remove() ;
  d3.selectAll(".verticaldashline").remove() ;
  d3.selectAll(".markertext").remove() ;
  d3.selectAll(".rubberline").remove() ;
  d3.selectAll(".rubberbackground").remove() ;
  d3.selectAll(".rubbertext").remove() ;

  dont_annotate = [];
  dont_annotate[0x10000] = true;	// Never label -idle- event
  // clear matches
  document.getElementById("matchcount").innerHTML = "";
  redrawUI();
}


function resetevents() {
  d3.selectAll(".graphlinex").remove();
  d3.selectAll(".ipcmark").remove();
  d3.selectAll(".markmark").remove();
}

function resetipc() {
  d3.selectAll(".ipcmark").remove();
}

function resetmark() {
  d3.selectAll(".markmark").remove();
}

// Look at the displayed x-axis extent, backmapping to data values
// via x_zoomed scaler
function resetonscreen_x() {
//console.log("resetonscreen_x");
  // Initialize the left and right time values
  var xleft = x_zoomed.invert(0); 
  var xright = x_zoomed.invert(region3width); 
  var xrightmost = x_zoomed.invert(region3clipwidth);
  reset_globals_x(xleft, xright, xrightmost);
}

// Look at the displayed y-axis extent, backmapping to data values
// via y_zoomed scaler
function resetonscreen_y() {
//console.log("resetonscreen_y");
  // Initialize the top and bottom track values
  var ytop = Rnd0(y_zoomed.invert(0)); 
  var ybottom = Rnd0(y_zoomed.invert(region234height)); 
  reset_globals_y(ytop, ybottom);
}

// Use right (not rightmost) to auto-prune at X-axis edge, no slop
function rangeonscreen_x(lo, hi) {
  return (lo <= realxright && realxleft <= hi);
}

function onscreen_x(d) {	// Allow slop
  return (ts(d) <= realxrightmost && realxleft <= tsend(d));
}

function startsonscreen_x(d) {	// Allow slop
  return (ts(d) <= realxrightmost && realxleft <= (ts(d)));
}

function onscreen_ytrack(track, height) {
  return (track <= realybottom && realytop <= (track + height));
}

function onscreen_y(d) {
  var row = eventToRow[prefixCpu * 65536 + low16of(cpu(d))];
  var track = rowToTrack[row];
  var t_height = rowToHeight[row];
  return onscreen_ytrack(track + t_height / 4, 0);
}


// Round to zero decimal places
function Rnd0(x) {return Math.round(x);}

// Round to one decimal place
function Rnd1(x) {return Math.round(x * 10) / 10;}

// Input is a relative time, output is an absolute pixel position
function AbsPxX(tsrel) {return panzoomX(x(tsrel), state.savedtransformX);}

// Input is a cpu number, output is an absolute pixel position
function AbsPxY(cpu) {return y(cpu);}

// Input is a relative time, output is an absolute pixel position, rounded to 1/10 pixel
function AbsPxRX(tsrel) {return Rnd1(AbsPxX(tsrel));}

// Input is a cpu number, output is an absolute pixel position
function AbsPxRY(cpu) {return Rnd1(AbsPxY(cpu));}


// Unpack six characters from 32 bits. 
function Base40ToChar(base40) {
  var str = "";
  // Want uint32 but have int32: Simple code fails if arg is negative...
  var tempbase40 = (base40 >> 1) & 0x7fffffff;	// Positive, low bit missing
  var tempn40 = tempbase40 % 20;
  var c = kFromBase40.substr(tempn40 * 2 + (base40 & 1), 1);	// Puts back in low bit
  str += c;
  base40 = Math.floor(tempbase40 / 20);

  // First character went in last, comes out first
  while (base40 > 0) {
    var n40 = base40 % 40;
    var c = kFromBase40.substr(n40, 1);
    str += c;
    base40 = Math.floor(base40 / 40);
  }
  return str;
}


function ipcmark(dotg, centerx, centery, size, ipcd) {
  var xx = -size;
  var yy = size / 5;
  var offset = size * 3 / 4;
  var strokewidth = Rnd1(size / 20);
  var rad = Math.PI - ((ipcd * Math.PI) / 16);
  var sinangle = Math.sin(rad);
  var cosangle = Math.cos(rad);
  var path;
  // Offset and Rotate the center
  centerx2 = centerx + (offset * cosangle);
  centery2 = centery + (offset * -sinangle);
  if ((ipcd & 1) == 0) {
    // draw plain triangle
    path = "M" + (centerx2) + "," + (centery2) + 
               " L" + (centerx2 + (xx * cosangle) + (yy * -sinangle)) + "," +
               (centery2 - ((xx * sinangle) + (yy * cosangle))) +
               " L" + (centerx2 + (xx * cosangle) + (-yy * -sinangle)) + "," + 
               (centery2 - ((xx * sinangle) + (-yy * cosangle))) +
               " L" + (centerx2) +"," + (centery2);
  } else {
    // draw with notch
    path = "M" + (centerx2) + "," + (centery2) + 
               " L" + (centerx2 + (xx * cosangle) + (yy * -sinangle)) +"," +
               (centery2 - ((xx * sinangle) + (yy * cosangle))) +
               " L" + (centerx) +"," + (centery) +
               " L" + (centerx2 + (xx * cosangle) + (-yy * -sinangle)) +"," +
               (centery2 - ((xx * sinangle) + (-yy * cosangle))) +
               " L" + (centerx2) +"," + (centery2);
  }
  dotg.append("path")
    .attr("class", "ipcmark")
    .attr("d",  path)
    .attr("fill", "#FFFFFF")		// white
    .attr("stroke-width", strokewidth)	
    .attr("stroke", ipc_color[ipcd >> 2]);	// gray/blue/red
}

function drawemptylegend(lx, ly, lheight, lwidth) {
  d3.selectAll(".ipclegend").remove();
  d3.selectAll(".ipcmark").remove();
  svgdotg.append("rect")
    .attr("class", "ipclegend")
    .attr("x", lx)
    .attr("y", ly)
    .attr("height", lheight)
    .attr("width", lwidth)
    .attr("style", "fill:rgb(224,224,224); opacity:0.25");

}


function drawipclegend(lx, ly, lheight, lwidth) {
  d3.selectAll(".ipclegend").remove();
  svgdotg.append("rect")
    .attr("class", "ipclegend")
    .attr("x", lx)
    .attr("y", ly)
    .attr("height", lheight)
    .attr("width", lwidth)
    .attr("style", "fill:rgb(224,224,224); opacity:0.875");

  //var centerx = lx + 12;
  //var centery = ly + 10;
  var centerx = lx + 0.25 * lwidth;
  var centery = ly + 0.025 * lheight;
  var txtmul = textmultiplier_tbl[state.textmultiplier_value];

  svgdotg.append("text")
    .attr("class", "ipclegend")
    .attr("transform", "translate(" + (centerx + 8) + "," + 
                                      (centery + 2) + ")scale(1,1)")
    .attr("font-size", axisSmallTickPx)
    .attr("fill", "black")
    .attr("font-family", "sans-serif")
    .style("text-anchor", "left")
    .text("IPC");

  var iincr = (txtmul >= 1.5) ? 2 : 1;
  for (var i = 0; i < 16; i += iincr) {
    var centerx_i = centerx + ipctextoffset[i >> 2] + 10;
    var centery_i = centery + (i + (i >> 2) + 1) * lheight / 20;
    ipcmark(svgdotg, centerx, centery_i, 20 * txtmul, i);

    svgdotg.append("text")
      .attr("class", "ipclegend")
      .attr("transform", "translate(" + (centerx_i) + "," + 
                                    (centery_i + 2) + ")scale(1,1)")
      .attr("font-size", axisSmallTickPx)
      .attr("fill", "black")
      .attr("font-family", "sans-serif")
      .style("text-anchor", "left")
      .text(ipcvalues[i]);
  }
}




// Add relative drawing ops to make a
function HexBox(txwidth2, txheight2) {
  var box = 
    " l" + (txwidth2) + ",2" + 
    " l0," + (txheight2 * 2) +
    " l" + (-txwidth2) + ",2" + 
    " l" + (-txwidth2) + ",-2" + 
    " l0," + (txheight2 * -2) +
    " l" + (txwidth2) + ",-2"; 
  return box;
}


//  perTracksize[i].annotheight pix height for drawing annotation text
//  perTracksize[i].eventoffset pix offset for event centerline
//  perTracksize[i].annotoffset pix offset for annot[0] text baseline

function draw_mark(row, d, x0, y0) {
  var t_height = rowToHeight[row];
  var marktextsize = perTracksize[t_height].annotsize;
  var x0 = x0;
  var y0 = y0; 
  ////var rel_y0 = Rnd1(t_height * 0.55);
  var rel_y0 = perTracksize[t_height].annotoffset - 
    perTracksize[t_height].eventoffset - marktextsize;
  //var rel_y0 = 12;
  var markcolor;
  var marktext;
  var alignleft = false;
  var alignright = false;
  var aligndown = false;

  if (ev(d) == 0x020A) {
    // mark_a comes in red left-right pairs, right if text starts with slash
    markcolor = "#FF0000";  // red
    marktext = Base40ToChar(arg0(d));
    if (marktext.substr(0,1) == "/") {alignright = true;}
    else {alignleft = true;}
  }
  if (ev(d) == 0x020B) {
    // mark_b comes in lowered blue left-right pairs, right if text starts with slash
    markcolor = "#0000FF";  // blue
    marktext = Base40ToChar(arg0(d));
    aligndown = true;
    if (marktext.substr(0,1) == "/") {alignright = true;}
    else {alignleft = true;}
  }
  if (ev(d) == 0x020C) {
    // mark_c comes in centered green 
    markcolor = "#008000";  //  dark green
    marktext = Base40ToChar(arg0(d));
  }
  if (ev(d) == 0x020D) {
    // mark_d comes in numbered centered black 
    markcolor = "#000000";  // black
    marktext = arg0(d).toString();
  }
        
  var txwidth2;
  var txheight2;
  var markpath;
  if (ev(d) == 0x020D) {
    // Bare text with narrow triangle
    txwidth2 = Rnd1((marktext.length) * marktextsize * 0.6 / 2);
    markpath = "M" + x0 + "," + y0 + " l-2," + rel_y0 +
      " l4,0";
  } else {
    // Boxed text with line
    txwidth2 = Rnd1((1 + marktext.length) * marktextsize * 0.6 / 2);
    txheight2 = Rnd1(marktextsize * 1.2 / 2);
    markpath = "M" + x0 + "," + y0 + " l0," + rel_y0;
    if (aligndown) {
      y0 += Rnd1(marktextsize); 
      markpath += " l0," + Rnd1(marktextsize);
    }
    if (alignleft) {x0 += txwidth2; markpath += " l0,2 m" + (txwidth2) + ",-2";}
    if (alignright) {x0 -= txwidth2; markpath += " l0,2 m" + (-txwidth2) + ",-2";}
    // Add hexagon box. height2/width2 are half full ones
    markpath += HexBox(txwidth2, txheight2);
  } 

  innersvgdotg.append("path")
    .attr("class", "markmark")
    .attr("d",  markpath)
    .attr("fill", "none")
    .attr("stroke-width", 1)
    .attr("stroke", markcolor);

  // Skip showing some mark_d numbers if they would overlap
  var skiptext = false; 
  if (ev(d) == 0x020D) {
    skiptext = ((x0 - txwidth2) < rightmostnum[row]);
  }
  if (!skiptext) {
    innersvgdotg.append("text")
      .attr("class", "markmark noselect")
      .attr("transform", "translate(" + (x0) + "," + (y0 + rel_y0) + ")scale(1,1)")
      .attr("dy", marktextsize)
      .attr("font-size", marktextsize + "px")
      .attr("fill", markcolor)
      .attr("font-family", "sans-serif")
      .style("text-anchor", "middle")
      .text(marktext);
    rightmostnum[row] = x0 + txwidth2;
  }
}

// Annotate all items on screen. Use sparingly at deep zoom only...
//       row = getrow(d, prefixCpu);
//       make min_ts per row
function draw_annotateall() {
  // Remove any previous lines
  resetlines();

  // To reduce clutter, don't annotate the same user-mode item repeatedly
  state.annotated_d = [];
  state.annotated_one_d = -1;
  dont_annotate = [];
  dont_annotate[0x10000] = true;	// Never label -idle- event
  resetRotatingLabelk();

  // Draw all lines
  var min_ts = 0;	// But only one per xsecperpix
  if (data == null) {return;}
  for (var i = 0; i < data.events.length; ++i) {
    var d = data.events[i];
    var gray = !eventHilite(i);
    var skip = gray || dont_annotate[ev(d)] || is_mark(d) || is_arc(d);
    if (startsonscreen_x(d) && onscreen_y(d) && !skip) {
      if (min_ts <= tsrel(d)) {
        var short = true;
        var rotate = true;
        annotatespan(d, "first", short, -1, rotate);
        if (is_user(d)) {dont_annotate[ev(d)] = true;}
        min_ts = tsrel(d) + xsecperpix;
        state.annotated_d.push(i);
        if(state.annotated_one_d == -1) {state.annotated_one_d = i;}  // Keep first
      }
    }
  }
}

function draw_annotateuser() {
  // Remove any previous lines
  resetlines();

  // To reduce clutter, don't annotate the same user-mode item repeatedly
  state.annotated_d = [];
  state.annotated_one_d = -1;
  dont_annotate = [];
  dont_annotate[0x10000] = true;	// Never label -idle- event
  resetRotatingLabelk();

  // Draw first of each user-mode line
  var min_ts = 0;	// But only one per xsecperpix
  if (data == null) {return;}
  for (var i = 0; i < data.events.length; ++i) {
    var d = data.events[i];
    var gray = !eventHilite(i);
    var skip = gray || !is_user(d) || !startsonscreen_x(d) || !onscreen_y(d);
    if (skip) {continue;}
    // Suppress some kernel-thread names 
    //if(name(d).substr(0, 5) == "ksoft") {dont_annotate[ev(d)] = true;}
    //if(name(d).substr(0, 5) == "kwork") {dont_annotate[ev(d)] = true;}
    //if(name(d).substr(0, 4) == "irq/") {dont_annotate[ev(d)] = true;}
    //if(name(d).substr(0, 3) == "rcu") {dont_annotate[ev(d)] = true;}
    skip |= dont_annotate[ev(d)];
    skip |= (name(d).substr(0, 1) == ".");
    if (!skip) {
      if (min_ts <= tsrel(d)) {
        var short = true;
        var rotate = true;
        annotatespan(d, "first", short, -1, rotate);
        dont_annotate[ev(d)] = true;
        min_ts = tsrel(d) + xsecperpix;
        state.annotated_d.push(i);
        if(state.annotated_one_d == -1) {state.annotated_one_d = i;}  // Keep first
      }
    }
  }
}

function drawOneIpc(row, d, x0, y0, e_height) {
  var draw_kernel = (state.ipc_value & 1) != 0;
  var draw_user   = (state.ipc_value & 2) != 0;
  var txtmul = textmultiplier_tbl[state.textmultiplier_value];
  if ((draw_kernel && is_kernel(d)) || (draw_user && is_useroridle(d))) {
    var centerx = x0;
    var centery = y0;
    var ipcd = ipc(d);
    ////ipcmark(innersvgdotg, centerx, centery, 15 * txtmul, ipcd);
    ipcmark(innersvgdotg, centerx, centery, e_height, ipcd);
  }
}

function drawOneMark(row, d, x0, y0) {
  var draw_numeric = (state.marks_value & 1) != 0;
  var draw_text = (state.marks_value & 2) != 0;
  if ((draw_text && ev(d) != 0x20D) || (draw_numeric && ev(d) == 0x20D)) {
    draw_mark(row, d, x0, y0);
  }
}

// Draw dotted hexagon around and label area that is expanded later
function draw_bracket(d, left_t, right_t) {
    // Draw top of diagram bracket
    var left_x = panzoomX(x(left_t), state.savedtransformX);
    var right_x = panzoomX(x(right_t), state.savedtransformX);
    var height_y =  diagramheight - 30;
    var top_y = y(0) - linewidth.k4 * 0.8;
    var bottom_y = top_y + height_y;
    var path1 = "M" + Rnd1(left_x - 6) + "," + Rnd1(top_y + (height_y / 2)) +
                " L" + Rnd1(left_x) + "," + Rnd1(top_y) +
                " H" + Rnd1(right_x) +
                " L" + Rnd1(right_x + 6) + "," + Rnd1(top_y + (height_y / 2));
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path1)
      .attr("fill", "none")
      .attr("stroke-dasharray", [1,5])
      .attr("stroke-width", 2)
      .attr("stroke", "#404040");	// mid-gray

    // Draw bracket text
    var brackettext = innersvgdotg.append("text");
    brackettext 
      .attr("transform", 
             "translate(" + ((left_x + right_x) / 2) + "," + (top_y - 4) + ")")
      .attr("class", "brackettext")
      .attr("font-size", axisSmallTickPx)
      .text(name(d));

    // Draw bottom of diagram bracket
    var path2 = "M" + Rnd1(left_x - 6) + "," + Rnd1(bottom_y - (height_y / 2)) +
                " L" + Rnd1(left_x) + "," + Rnd1(bottom_y) +
                " H" + Rnd1(right_x) +
                " L" + Rnd1(right_x + 6) + "," + Rnd1(bottom_y - (height_y / 2));
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path2)
      .attr("fill", "none")
      .attr("stroke-dasharray", [1,5])
      .attr("stroke-width", 2)
      .attr("stroke", "#404040");	// mid-gray

}

// Draw oval around one CPU line and fade everything outside it
function draw_oval(d, left_t, right_t) {
    // Draw top of diagram bracket
    var left_x = panzoomX(x(left_t), state.savedtransformX);
    var right_x = panzoomX(x(right_t), state.savedtransformX);
    var mid_y = y(cpu(d)) + linewidth.k4 * 0.4;
    var top_y = mid_y - linewidth.k4 * 1.1;
    var bottom_y = mid_y + linewidth.k4 * 1.1;

// How can we fill with alpha?
// fill-opacity: This attribute takes a decimal number between 0.0 and 1.0, inclusive; 
// where 0.0 is completely transparent.
    // Draw outer shape clockwise; draw inner shape counter-clockwise
    // Z closepath followed by moveto continues
    // Rectangle: 0, diagramheight   0,0   diagramwidth,0   diagramwidth,diagramheight  closepath 
    // Oval corners:  left_x,top_y   left_x,bottom_y   right_x,bottom_y   right_x,top_y   closepath 
    // Q 50 10 100 75

    // Start at bottom left corner; go in a bit
    var path3 = "M" + Rnd1(0 + 2) + "," + Rnd1(diagramheight - 2) +
                " V" + Rnd1(0 + 2) + 
                " H" + Rnd1(diagramwidth - 2) +
                " V" + Rnd1(diagramheight - 2) + 
                " Z" +
                " M" + Rnd1(left_x) + "," + Rnd1(top_y) +
                " Q" + Rnd1(left_x - 6) + "," + Rnd1(mid_y) + "," +
                       Rnd1(left_x) + "," + Rnd1(bottom_y) + 
                " H" + Rnd1(right_x) +
                " Q" + Rnd1(right_x + 6) + "," + Rnd1(mid_y) + "," +
                       Rnd1(right_x) + "," + Rnd1(top_y) + 
                " Z";
   innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path3)
      .attr("stroke", "none")
      .attr("fill", "#FFFFFF")
      .attr("fill-opacity", 0.8);
}

// Rotate <x,y> w.r.t. <0.0>
function xyrotate(xypair, sincospair) {
  var xyresult = {x:0, y:0};
  xyresult.x = xypair.x * sincospair.cos - xypair.y * sincospair.sin;
  xyresult.y = xypair.x * sincospair.sin + xypair.y * sincospair.cos;
  return xyresult;
}
 
// Arc starts at <tsrel, cpu> and goes to <tsrel + dur, cpu2>, where
// cpu2 is stored in the arg0 field

function draw_arc(row, d, x0, y0, x1, y1) {
  if (state.arcs_value == 0) {return;}

  var left_x = x0;
  var right_x = x1;

  // Suppress arcs that are a small fraction of the display window
  //  if the window width is greater than 5 milliseconds
  var short_span = ((right_x - left_x) < (region3width * arcfraction));
  var long_window = (xdomainwidth > 0.005);
  if (short_span && long_window) {return;}

  var left_y = y0;
  var right_y = y1;
  var mid_x = (left_x + right_x) / 2;
  var mid_y = (left_y + right_y) / 2;

  // Control point needs to be rotated wrt left ==> right line
  var arc_run = right_x - left_x;
  var arc_rise = right_y - left_y;
  var arc_hypot = Math.sqrt(arc_run * arc_run + arc_rise * arc_rise);
  var sincospair = {sin:0, cos:1};
  sincospair.sin = arc_rise / arc_hypot;
  sincospair.cos = arc_run / arc_hypot;
  // Control point of arc is at <0,10> px rotated
  var ctl_rot = xyrotate({x: 0, y: -30}, sincospair);

  // Arrow angle needs to be wrt control_point ==> right line
  var ctl_run = right_x - (mid_x + ctl_rot.x);
  var ctl_rise = right_y - (mid_y + ctl_rot.y);
  var ctl_hypot = Math.sqrt(ctl_run * ctl_run + ctl_rise * ctl_rise);
  sincospair.sin = ctl_rise / ctl_hypot;
  sincospair.cos = ctl_run / ctl_hypot;
  var arrow_rot = xyrotate({x: -8, y: -8}, sincospair);

  var arc_path = "M" + Rnd1(left_x) + "," + Rnd1(left_y) +
                 " Q" + Rnd1(mid_x + ctl_rot.x) + "," +
                     Rnd1(mid_y + ctl_rot.y) + "," +
                     Rnd1(right_x) + "," + Rnd1(right_y) + 
                 " l" + Rnd1(arrow_rot.x) + "," + Rnd1(arrow_rot.y);

  innersvgdotg.append("path")
    .attr("class", "graphlinex")
    .attr("d", arc_path)
    .attr("fill", "none")
    .attr("stroke-width", 1.0)
    .attr("stroke-dasharray", [3,3])
    .attr("stroke", "#0080FF");
//      .attr("stroke", "#AA00FF");
}


// TODO: bracket and oval are broken. Need position updates like arc
function overlaydraw(d, gray) {
  var left_t = tsrel(d);
  var right_t = tsrel(d) + dur(d);
  if (is_bracket(d)) {
    draw_bracket(d, left_t, right_t);
  } else if (is_oval(d)) {
    draw_oval(d, left_t, right_t);
  } else if(!gray && is_arc(d)) {
    var x0 = x_zoomed(ts(d));
    var x1 = x_zoomed(tsend(d));
    var row0 = eventToRow[prefixCpu * 65536 + low16of(cpu(d))];
    var track0 = rowToTrack[row0];
    var t_height0 = rowToHeight[row0];
    var e_height0 = perTracksize[t_height0].eventheight;
    var y0 = y_zoomed(track0) + perTracksize[t_height0].eventoffset - (e_height0 / 2);
    var row1 = eventToRow[prefixCpu * 65536 + low16of(cpu2(d))];
    var track1 = rowToTrack[row1];
    var t_height1 = rowToHeight[row1];
    var e_height1 = perTracksize[t_height1].eventheight;
    var y1 = y_zoomed(track1) + perTracksize[t_height1].eventoffset - (e_height1 / 2);
    draw_arc(row0, d, x0, y0, x1, y1);
  }
}


//  drawOneEntry(rowToTrack[row], rowToHeight[row], d, options)

// Draw one entry on given track. Gray'd entries skip marks and IPC and arcs
function slowDrawOnRow(row, d, gray) {
  var track = rowToTrack[row];
  var t_height = rowToHeight[row];
  var x0 = x_zoomed(ts(d));
  var x1 = x_zoomed(tsend(d));
  var y0 = y_zoomed(track) + perTracksize[t_height].eventoffset;
  var e_height = perTracksize[t_height].eventheight;

  if (e_height < 7) {
    // Too small to see well -- draw as single line
    fastDrawOnRow(row, d, gray);
    return;
  }

  var path = "M" + Rnd1(x0) + "," + Rnd1(y0) + " H" + Rnd1(x1);
  if (is_kernel(d)) {
//console.log("kernel", path);
    // Draw the syscall/irq/fault four lines
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path)
      .attr("fill", "none")
      .attr("stroke-width", l4width(d, e_height))
      .attr("stroke", l4color(d, gray));
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path)
      .attr("fill", "none")
      .attr("stroke-width", l3width(d, e_height))
      .attr("stroke", l3color(d, gray));
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path)
      .attr("fill", "none")
      .attr("stroke-width", l2width(d, e_height))
      .attr("stroke", l1color(d, gray));
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path)
      .attr("fill", "none")
      .attr("stroke-width", l1width(d, e_height))
      .attr("stroke", l2color(d, gray));

  } else if (is_user(d)) {
    // Draw stacked user colors
    var path1 = "M" + Rnd1(x0) + "," + Rnd1(y0 - (l1width(d, e_height) / 2)) + 
      " H" + Rnd1(x1);
    var path2 = "M" + Rnd1(x0) + "," + Rnd1(y0 + (l2width(d, e_height) / 2)) + 
      " H" + Rnd1(x1);
//console.log("user", path1, path2);
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path1)
      .attr("fill", "none")
      .attr("stroke-width", l2width(d, e_height))
      .attr("stroke", l2color(d, gray));
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path2)
      .attr("fill", "none")
      .attr("stroke-width", l1width(d, e_height))
      .attr("stroke", l1color(d, gray));

  } else if (is_idle(d)) {
//console.log("idle", path);
    // Draw the idleline
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path)
      .attr("fill", "none")
      .attr("stroke-width", l1width(d, e_height))
      .attr("stroke", l1color(d, gray));

  } else if(is_c_exit(d)) {
    var sinewidth = x1 - x0;
    var sineheight = 0.5 * e_height;
    var path3 = "M"  + Rnd1(x0) + "," + Rnd1(y0) + 
                " Q" + Rnd1(x0 + 0.25 * sinewidth) +"," + Rnd1(y0 - sineheight) +
                " "  + Rnd1(x0 + 0.50 * sinewidth) +"," + Rnd1(y0) +
                " Q" + Rnd1(x0 + 0.75 * sinewidth) +"," + Rnd1(y0 + sineheight) +
                " "  + Rnd1(x0 + 1.00 * sinewidth) +"," + Rnd1(y0);
//console.log("cexit", path3);
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path3)
      .attr("fill", "none")
      .attr("stroke-width", Rnd1(linewidth.idle) )
      .attr("stroke", gray ? "#949494" :"#C00000" );	// darkish red

  } else if (is_special(d) && !is_mark(d)) {
    // Mostly IPIsend, RPCmarkers; duration is non-zero
    // Offset 1/3 line up, make 5x wider to be more visible
    right_t = tsrel(d) + 5 * dur(d);
    var path4 = "M" + Rnd1(x0) + "," + Rnd1(y0 - e_height / 3) + " H" + Rnd1(x1);
//console.log("special", path4);
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path4)
      .attr("fill", "none")
      .attr("stroke-width", e_height)
      .attr("stroke", l2color(d, gray));

  } else if(!gray && is_mark(d)) {
    drawOneMark(row, d, x0, y0);

  } else {
    // Draw nothing
  }

  // Layer on top the IPC triangle
  if (!gray && (0 <= state.ipc_value)) {
    drawOneIpc(row, d, (x0 + x1) / 2, y0, e_height * 0.67);
  }
}


// Draw one small entry on given track, using just one line and color. Skip marks and IPC
function fastDrawOnRow(row, d2, gray) {
  var track = rowToTrack[row];
  var t_height = rowToHeight[row];
  var x0 = x_zoomed(ts(d2));
  var x1 = x_zoomed(tsend(d2));
  var y0 = y_zoomed(track) + perTracksize[t_height].eventoffset;
  var e_height = perTracksize[t_height].eventheight;

  var path = "M" + Rnd1(x0) + "," + Rnd1(y0) + " H" + Rnd1(x1);

  if (is_kernel(d2)) {
    // Just draw the syscall/irq/fault background color
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path)
      .attr("fill", "none")
      .attr("stroke-width", l3width(d2, e_height))
      .attr("stroke", l3darkcolor(d2, gray));
  } else if (is_user(d2)) {
    // Just draw the user top color
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path)
      .attr("fill", "none")
      .attr("stroke-width", l2width(d2, e_height) + l1width(d2, e_height))
      .attr("stroke", l2color(d2, gray));
  } else if (is_idle(d2)) {
    // Draw the idle line
    innersvgdotg.append("path")
      .attr("class", "graphlinex")
      .attr("d",  path)
      .attr("fill", "none")
      .attr("stroke-width", l1width(d2, e_height))
      .attr("stroke", l1color(d2, gray));
  } else {
    // Draw nothing
  }
}




// if ev is idle, only overwrite 0 
// if ev is user, only overwrite 0, idle 
// if ev is kernel, overwrite
// if < kernel, skip 
function Replace_ev(old_ev, new_ev) {
  if (new_ev < 0x400) {return false;} 
  if (is_c_exit(new_ev)) {return false;}
  return true;
  if (old_ev == 0) {return true;}
  if (is_kernel_ev(new_ev)) {return true;}
  if (is_user_ev(new_ev) && !is_kernel_ev(old_ev)) {return true;}
  return false;
}

// Draw one event on the specified row, if onscreen
function drawOnRow(row, d, gray) {
  if (row < 0) {return;}
  if (rowToHeight[row] == 0) {return;}
  var is_onscreen = onscreen_ytrack(rowToTrack[row], rowToHeight[row]);
  if (!is_onscreen) {return;}
//console.log("  drawOnRow", row, rowToTrack[row], rowToHeight[row], d);
  var can_defer = true;
  //if (is_mark(d)) {can_defer = false;}
  if (is_mark(d)) {
    can_defer = false;
    // Defer (delete entirely) if it is not at least 3px beyond previous mark
    // But no defer if sscreen width is less than 5 msec
    var long_window = (xdomainwidth > 0.005);
    var ts0 =ts(d);
//console.log("high[", row, "] ", ts0,  highwater_mark[row]);
    if (long_window && (ts0 < highwater_mark[row])) {return;}
    highwater_mark[row] = ts0 + 3 * xsecperpix;
//console.log("  keep\n");
  }


// zzzz
//  slowDrawOnRow(row, d, gray);
//  return;

// To attach later: important performance optimization with 1M events 

  if (can_defer && ((defer_dur[row] + dur(d)) < xsecperpix)) {
    // Accumulate tiny intervals
    defer_dur[row] += dur(d);
    if      (is_idle(d)) {
      defer_dur_i[row] += dur(d);
    } else if (is_user(d)) {
      defer_dur_u[row] += dur(d);
      defer_event_u[row] = ev(d);
    } else if (is_kernel(d)) {
      defer_dur_k[row] += dur(d);
      defer_event_k[row] = ev(d);
    }
  } else {
    // Flush deferred and then draw any bigger event
    if (defer_dur[row] > 0) {
      // Flush deferred event, just in front of d
      var d2 = [];
      for (var j = 0; j < 10; ++j) {d2[j] = d[j];}
      set_ts(d2, ts(d) - defer_dur[row]);
      set_dur(d2, defer_dur[row]);
      set_ev(d2, defer_event_k[row]);	// Default to most recent kernel
      if ((defer_dur_i[row] > defer_dur_u[row]) &&
          (defer_dur_i[row] > defer_dur_k[row])) {
        set_ev(d2, 0x10000);		// idle took most time
      } else if ((defer_dur_u[row] > defer_dur_i[row]) &&
                 (defer_dur_u[row] > defer_dur_k[row])) {
        set_ev(d2, defer_event_u[row]);	// most recent user took most time
      }
      fastDrawOnRow(row, d2, gray);
      resetDefer(row);
    }
    // Defer (if small) or draw (if large) new event
    if (can_defer && ((defer_dur[row] + dur(d)) < xsecperpix)) {
      // Accumulate tiny new event after flushing deferred event
      defer_dur[row] += dur(d);
      if      (is_idle(d)) {
        defer_dur_i[row] += dur(d);
      } else if (is_user(d)) {
        defer_dur_u[row] += dur(d);
        defer_event_u[row] = ev(d);
      } else if (is_kernel(d)) {
        defer_dur_k[row] += dur(d);
        defer_event_k[row] = ev(d);
      }
    } else {
      // Draw larger event after flushing deferred event
      slowDrawOnRow(row, d, gray);
    }
  }

  // Draw optional markers (do this first so IPC legend overlays)
  //redrawMarks();
  //redrawIpc();

}

// Highlight if in set, treating empty set as highlight-all
function eventHilite(i) {
  if (state.hilite_event_set.size == 0) return true;
  return state.hilite_event_set.has(i);
}

// Highlight if in set, treating empty set as highlight-none
function rowHilite(row) {
  return state.hilite_row_set.has(row);
}

// Full height if in set, treating empty set as highlight-all
function rowFullsize(row) {
  if (state.hilite_row_set.size == 0) return true;
  return state.fullsize_row_set.has(row);
}



// Here is the plan:
// If not onscreen, continue
// Define tiny as less than, say, 1/2 pixel wide. 
// Calc once per draw the duration width this means
// If (defer[cpu] + dur) < xsecperpix, defer[cpu] += dur
// else 
//   fastdraw non-zero defer, set defer[cpu]=0, deferevent[cpu]=none
//   if (defer[cpu] + dur) < xsecperpix, defer[cpu] += dur deferevent[cpu] = event
//   else draw dur
//
// defer dur sum
//   x  x   lg  fastdraw defer, zero it, retry: += dur
//     0  x   sm  defer += dur
//     0  x   lg  draw dur
//
//   x  x   sm  += dur
//
// The above for is_idle/is_cexit/user/is_kernel spans
// marks:      20a..20d	space them at least xsecperpix*2 apart
// is_special: 20x	space them at least xsecperpix*2 apart
// ipc:			space them at least xsecperpix*2 apart
// is_cexit: only draw if >= 10 * xsecperpix
//

function fastdrawevents() {
//console.log("fastdrawevents [", data.events.length, 
//            "], mindur", xsecperpix, 
//            " ====================================");
  resetevents();
  initializeDrawingState();
  if (data == null) {return;}

  // Draw everything on screen, except overlays
  d3.selectAll(".brackettext").remove() ;

  // Draw everything on screen except overlays
  var row = 0;
  var has_overlay = false;
  for (var i = 0; i < data.events.length; ++i) {
    var d = data.events[i];
    if (!onscreen_x(d)) {continue;}
    if (is_any_overlay(d)) {has_overlay = true; continue;}

    var gray = !eventHilite(i);
    var cpu_d = cpu(d);
    if (0 <= cpu_d) {
      row = eventToRow[prefixCpu * 65536 + low16of(cpu_d)];
//console.log("cpu ________", row);
      if (0 <= row) {drawOnRow(row , d, gray);}
    }

    var pid_d = pid(d);
    if (0 < pid_d) {		// Do not draw pid=0, idle
      row = eventToRow[prefixPid * 65536 + low16of(pid_d)];
//console.log("pid", row);
      if (0 <= row) {drawOnRow(row , d, gray);}
    }

    var rpc_d = rpc(d);
    if (0 < rpc_d) {		// Do not draw rpc=0, not inside an RPC
      row = eventToRow[prefixRpc * 65536 + low16of(rpc_d)]; 
//console.log("rpc", row);
      if (0 <= row) {drawOnRow(row , d, gray);}
    }

    var res_d = res(d);
    if (0 <= res_d) {
      row = eventToRow[prefixRes * 65536 + low16of(res_d)];
//console.log("res", row);
      if (0 <= row) {drawOnRow(row , d, gray);}
    }
  }

  // Draw any manual overlay items last
  if (has_overlay) {
    for (i = 0; i < data.events.length; ++i) {
      var gray = !eventHilite(i);
      var d = data.events[i];
      if (is_any_overlay(d)) {overlaydraw(d, gray);}
    }
  }
}

// BUG: strictly speaking, the left/right top/bottom should map just the
//   +/-5 pixel domain, not full region3width/region234height.
//   But the scaling below is correct, since both range and domain are large by 5px

// Width across the diagram is region3width pixels
// Width across the diagram is xdomainwidth seconds
// One pixel is xdomainwidth / width seconds
function reset_globals_x(xleft, xright, xrightmost) {
//console.log("reset_globals_x", xleft, xright);
  realxleft = xleft;
  realxright = xright;
  realxrightmost = xrightmost;
  xdomainwidth = Math.abs(xright - xleft);
  xsecperpix = (xdomainwidth / region3width) * xpixelfraction;
//console.log("NSEC per pixel", Math.round(xsecperpix * 1000000000.0));
}

// Height across the diagram is region234height pixels
// Height across the diagram is ydomainwidth tracks
// One track is region234height / ydomainwidth pixels
//   Note: this is the inverse of the ratio used for X-axis time above
function reset_globals_y(ytop, ybottom) {
//console.log("reset_globals_y", ytop, ybottom);
  realytop = ytop;
  realybottom = ybottom;
  ydomainwidth = Math.abs(ytop - ybottom);
  ypixpertrack = (region234height / ydomainwidth) * ypixelfraction;
  calcPixHeightsPerTrack(ypixpertrack);
}




// Because of auto-pruning of Y-axis rows that cannot possibly overlap the X span
// on screen, updating X will in general require also updating the Y-axis
function do_zoomed_x() { 
//console.log("do_zoomed_x ----------", d3.event.transform.k);
  // Pick up  the new transform and apply it
  state.savedtransformX = d3.event.transform;
  state.savedtransformX.y = 0;	// Scrolling X does not change Y
	
  // Renumber the track heights per row, to auto-prune rows no longer visible
  // Use x_zoomed when drawing everything after this  
  // Set up x_zoomed, y_zoomed and Recalculate X- and Y- on-screen limits
  updateTracks();
  y.domain([0, maxTrack]);
  resetRangeDomain();
  calcPixHeightsPerTrack(ypixpertrack);

  // Remember nearest annotated event to the mouse click, to display after pan
  var m = d3.mouse(this);
  var mx = m[0];
  var my = m[1];
  var t = x_zoomed.invert(mx);
  var y_track = y_zoomed.invert(my);
  if (0 <= y_track) {
    state.annotated_one_d = FindNearestAnnotated(t);
  }

  // Turn off annotateall/user after pan/zoom
  state.annotateall_value = 0;
  state.annotateuser_value = 0;


  // Nothing below this depends on d3.event
  // ---------------------------------------
  redrawEventsEtc();

  // Axes depend on calculateBasetime in redrawEventsEtc
  // Redraw the zoomed X-axis and grid
  redrawXaxis();

  // Redraw the pruned Y-axis
  ////redrawYaxis();
  redrawYlabels();

//console.log("end do_zoomed_x ----------");
}


// Tracks contain event lines and annotation text, split in some proportion
// The pixel height for a trackheight is ypixpertrack * t_height
// The font-size for annotation text has a minimum and grows slowly, allowing
// room for 0..4+ lines depending on zoom. It is 8 + (xx - 8) / 6
// Event offset is forced to be an integer number of pixels, to allow
//  subscripting by Y-position
// NO. give up on offsets being exact integers. use rnd1
//
function calcPixHeightsPerTrack(pixpertrack) {
//console.log("calcPixHeightsPerTrack", pixpertrack);
  // Calculate sizes and offsets per track height 1..10
  var minannot = Math.min(14, Math.max(6, 0.75 * textsize.smalltick));
  for (var i = 0; i <= maxTrackHeight; ++i) {
    perTracksize[i] = {};
    var trackheight = i * pixpertrack;
    var annotfontsize = minannot;
    var e_height;
    if (minannot < trackheight) {
      // Grow slowly
      annotfontsize += Rnd0((trackheight - minannot) / 20);
    }
    perTracksize[i].annotsize = annotfontsize;

    if ((annotfontsize * 2) <= trackheight) {
      // Normal case, allocate half the track height to events, half to annots
      e_height = Rnd1(trackheight / 2);
      perTracksize[i].eventheight = e_height;
      perTracksize[i].annotheight = trackheight - e_height;
      perTracksize[i].eventoffset = Rnd1(e_height / 2);		// Centered in top half
      perTracksize[i].annotoffset = Rnd1(trackheight / 2 + annotfontsize);
    } else if (annotfontsize <= trackheight) {
      // No room for annotations; hold event line height steady
      e_height = Rnd1(annotfontsize);
      perTracksize[i].eventheight = Rnd1(annotfontsize);
      perTracksize[i].annotheight = 0;
      perTracksize[i].eventoffset = Rnd1(e_height / 2);	// Centered near top
      perTracksize[i].annotoffset = Rnd1(trackheight + annotfontsize * 0.67);  
    } else {
      // No room for annotations and need to shrink event height
      e_height = Rnd1(trackheight);
      perTracksize[i].eventheight = e_height;
      perTracksize[i].annotheight = 0;
      perTracksize[i].eventoffset = Rnd1(e_height / 2);	// Centered near top
      perTracksize[i].annotoffset = Rnd1(trackheight + annotfontsize * 0.67);  
    } 
    perTracksize[i].annotcount = 
      Math.max(1, Math.trunc(perTracksize[i].annotheight / annotfontsize));
  }

//console.log("perTracksize", perTracksize);
}

function do_zoomed_y() { 
//console.log("do_zoomed_y ----------", d3.event.transform.k);
  // Pick up  the new transform and apply it
  state.savedtransformY = d3.event.transform;
  state.savedtransformY.x = 0;	// Scrolling Y does not change X

  // Set up offsets and line widths per track heights [1..10] 
	
  // Renumber the track heights per row, to auto-prune rows no longer visible
  updateTracks();
  y.domain([0, maxTrack]);
  resetRangeDomain();
  calcPixHeightsPerTrack(ypixpertrack);

  // Nothing below this depends on d3.event
  // ---------------------------------------

  // Turn off annotateall/user after pan/zoom
  state.annotateall_value = 0;
  state.annotateuser_value = 0;

  redrawEventsEtc();

  // Axes depend on calculateBasetime in redrawEventsEtc
  // Redraw the zoomed Y-axis
  redrawYlabels();

//console.log("end do_zoomed_y ----------");
}
 
// Save state, including awkward Sets, without changing anything
function packupState() {
  // First turn sets into arrays
  state.hilite_event_array = [...state.hilite_event_set.values()];
  state.hilite_row_array = [...state.hilite_row_set.values()];
  state.fullsize_row_array = [...state.fullsize_row_set.values()];
  // Note: it is difficult to get JavaScript to do true deep copy
  return JSON.parse(JSON.stringify(state));
}

// After restoring stare, put Sets back
function unpackState(saved) {
  state = JSON.parse(JSON.stringify(saved));
  // Last turn arrays back into sets
  state.hilite_event_set = new Set(state.hilite_event_array);
  state.hilite_event_array = [];
  state.hilite_row_set = new Set(state.hilite_row_array);
  state.hilite_row_array = [];
  state.fullsize_row_set = new Set(state.fullsize_row_array);
  state.fullsize_row_array = [];
}

// Reset zoom to original full trace
// Reset a few data-related pieces of state
// Save to state[0] just before resetting, in case reset is a mistake
function resetzoom() {
//console.log("resetzoom ==================");
  savedstate[0] = packupState();
  saved_valid[0] = true;

  // Reset parts of state
  state.groupcompress = [3, 0, 0, 0];	// Show CPUs, collapse others
  state.hilite_event_set.clear();
  state.hilite_row_set.clear();
  state.fullsize_row_set.clear();

  allocOuterSvgEtc();
}

//BUG
//BUG: on restore, sometimes RES ends up too low, below region2
//BUG  it appears that auto prune does not redo updateTracks, so track zoom 
//BUF  can to too big or too small. most easily seen when auto zoom and
//BUG  bottom pops up, rather than changing zoom slightly.
//BUG  then save with auto pruned followed by restore and then un-prune expands 
//BUG  below region2.
//BUG


 
// Annotate all items on whose name contains search string and 
// whose duration dur is mindur <= dur <= maxdur. 
function annotatesearch2(needle, mindur, maxdur) {
console.log("annotatesearch2", needle, mindur, maxdur);
  // Remove any previous lines
  resetlines();
  document.getElementById("matchcount").innerHTML = "";

  // Ignore 1-char searches and 1-digit minimum duration -- too many matches
  if (!IsActiveText(needle) && !IsActiveNumber(mindur) && !IsActiveNumber(maxdur)) {return;} 

  var mindurval = +mindur/ 1000000.0;	// Minimum duration in usec converted to seconds
  var maxdurval = +maxdur/ 1000000.0;	// Maximum duration in usec converted to seconds
  if (maxdurval == 0) {maxdurval = 999.9;}	// Turn empty box into ~17 minutes max

  state.annotated_d = [];
  state.annotated_one_d = -1;
  resetRotatingLabelk();

  // Draw all matching lines
  var min_ts = 0;	// But only one per xsecperpix
  var matchcount = 0;	// number of matches
  var durcount = 0;	// total duration of matches
  if (data == null) {return;}
  for (var i = 0; i < data.events.length; ++i) {
    var d = data.events[i];
    // Invert search match if state.searchnot_value = true
    if(startsonscreen_x(d) && 
       onscreen_y(d) &&
       ((fullname(d, false).search(needle) >= 0) != state.searchnot_value) &&
       (mindurval <= dur(d)) &&
       (dur(d) <= maxdurval)
      ) {
      if (min_ts <= tsrel(d)) {
        var short = true;
        var rotate = true;
        annotatespan(d, "first", short, -1, rotate);
        min_ts = tsrel(d) + xsecperpix;
        state.annotated_d.push(i);
        if(state.annotated_one_d == -1) {state.annotated_one_d = i;}  // Keep first
      }
      // Count even if not drawn
      ++matchcount;
      durcount += dur(d);
    }
  }
  document.getElementById("matchcount").innerHTML =
    matchcount + ", " + shortnum5(durcount);
}
 
 
// on mousedown -- start line at backmap of pos clientX clientY 
//  button=0 and shiftKey=true , remove any prior visible line
//  create mousemove mouseup listener
// mousemove -- continue line, redraw  clientX clientY
// moutseup -- abandon line if shiftKey=true
//                   keep line visible if shiftKey=false
// mouseout mouseleave -- ignore until mousein
// mouseenter mouseover
// d3.event.stopPropagation()
 

// To snap to nearest point, we have mouse point x,y scaled to data units and data array.
// Taking advantage of data being sorted by x value, we use bisect (binary search) to find a nearby point
// Then refine based on two nearby points to see closest x** + y**2. 
// THIS: Or not bother and just use closest x. Snap x1y1 or x2y2 to that point.
// Consider not snapping if too far away.
 
// For convenience, we want to binary search in raw client pixels.
// So in function(d) we map data into range/domain and then into pan/zoom
 

// TODO here:
//
// 1) map x-pixel to nearest ts(d):
//    map x-pixel to time
//    binary search time in ts(d), ignoring cpu# etc., giving data events subscript i
//    then refine to find closest ts..tsend range or perfect overlap
// 2) map y-pixel to nearest row:
//    map y-pixel to track
//    binary search track in rowToTrack/Height, giving y-row
//    then refine to find closest track..track+height range or perfect overlap,
//      favoring largest or at least non-zero height
//
// annotate does y-pixel nearest then x-pixel nearest, restricting to row(event) == y-row
//   for some field of the event. We can specify the field access function ahead of time
//
// drag works like annotate
//
// highlighting and expand/contract do y-pixel nearest == y-row
//   (no need for four group watchers)
//   highlight then scans onscreen events and adds any with 
//     row(event) == y-row to highlight set
//

// For convenience, we want to binary search in raw client pixels.
// So in function(d) we map data into range/domain and then into pan/zoom
 
 
// Snap raw input [x,y] pair to nearest x in data, returning [x',y'] of that point
// Note that we only look at the range [1..N-1] so that i-1 is always valid


// Map input x-pixel to time and then to nearest event in given row, using accessor rr
// Returns -1 if none found
function doSnap_x(x, row, rr) {
  var t = x_zoomed.invert(x);
  var ff = function(d) {return ts(d);};
  var bisectPoint = d3.bisector(ff).left;
  var i = bisectPoint(data.events, t, 1, data.events.length - 1);
//console.log("doSnap_x =", x, row, t, i, data.events[i]);

  // From this starting point, scan forward/backward to find first entry for
  // desired row
  var lo_i, hi_i;
  for (lo_i = i - 1; 0 <= lo_i; --lo_i) {
    if (rr(lo_i) == row) {break;}
  }	
  // Exits lo_i = -1 if not found

  // Not nearest event but just nearest to the left
   //for (hi_i = i; hi_i < data.events.length; ++hi_i) {
   //  if (rr(hi_i) == row) {break;}
   //}
   //// Exits hi_i = data.events.length if not found 
  hi_i = data.events.length;

//console.log("  expand", i, "lo,hi", lo_i, hi_i);


// TODO: break early if not onscreen
  if ((lo_i < 0) && (data.events.length <= hi_i)) {return -1;}	// Not found	
  if (data.events.length <= hi_i) {return lo_i;}		// No hi	
  if (lo_i < 0) {return hi_i;}					// No lo	

  var lo_point = ts(data.events[lo_i]);
  var hi_point = ts(data.events[hi_i]);
//console.log("  ", t, lo_point, hi_point);
  var nearest = lo_i;
  if (Math.abs(t - lo_point) > Math.abs(hi_point - t)) {nearest = hi_i;}
//console.log("  = i", nearest);
  return nearest;
}


// Map input y-pixel to track and then to nearest row
function doSnap_y(y) {
  var track = y_zoomed.invert(y);
  var bisectPoint = d3.bisector(function(d){return d;}).left;
  var row = bisectPoint(rowToTrack, track, 1, data.events.length - 1);
//console.log("doSnap_y =", y, track, row, rowToTrack[row]);

  var lo_point = rowToTrack[row - 1] + (rowToHeight[row - 1] / 2);
  var hi_point = rowToTrack[row] + (rowToHeight[row] / 2);
//console.log("  ", track, lo_point, hi_point);
  if ((track - lo_point) < (hi_point - track)) {--row;}
//console.log("  = row ", row);
  return row;
}

// These functions return a value from an event
var ff_cpu = function(d) {
  if (0 <= cpu(d)) {
    return cpu(d);
  }
  return -1;
}

var ff_pid = function(d) {
  if (0 < pid(d)) {
    return pid(d);
  }
  return -1;
}

var ff_rpc = function(d) {
  if (0 < rpc(d)) {
    return rpc(d);
  }
  return -1;
}

var ff_res = function(d) {
  if (0 <= res(d)) {
    return res(d);
  }
  return -1;
}

function getAccessor(row) {
  if (row < sortNum_pid_start) return (ff_cpu);
  if (row < sortNum_rpc_start) return (ff_pid);
  if (row < sortNum_res_start) return (ff_rpc);
  return (ff_res);
}



// These functions return a row number from an event
var rr_cpu = function(i) {
  var d = data.events[i];
  if (0 <= cpu(d)) {
    return eventToRow[prefixCpu * 65536 + low16of(cpu(d))];
  }
  return -1;
}

var rr_pid = function(i) {
  var d = data.events[i];
  if (0 < pid(d)) {
    return eventToRow[prefixPid * 65536 + low16of(pid(d))];
  }
  return -1;
}

var rr_rpc = function(i) {
  var d = data.events[i];
  if (0 < rpc(d)) {
    return eventToRow[prefixRpc * 65536 + low16of(rpc(d))];
  }
  return -1;
}

var rr_res = function(i) {
  var d = data.events[i];
  if (0 <= res(d)) {
    return eventToRow[prefixRes * 65536 + low16of(res(d))];
  }
  return -1;
}

// Return an accessor that maps an entry to a row within the right group
function getAccessorRR(row) {
  if (row < sortNum_pid_start) return (rr_cpu);
  if (row < sortNum_rpc_start) return (rr_pid);
  if (row < sortNum_res_start) return (rr_rpc);
  return (rr_res);
}


// Snap raw input [mx,my] pair to nearest in data, returning event subscript
function FindNearestEvent(mx, my) {
  var row = doSnap_y(my);
  if (0 > row) {return -1;}

  var ff = function(d) {return ts(d);};
  var rr = getAccessorRR(row);
  var nearest = doSnap_x(mx, row, rr);
//console.log("==== FindNearestEvent:", mx, my, row, nearest, "of", data.events.length);  
  return nearest;
}

var soft_irq_name = [
  "hi", "timer", "net_tx", "net_rx",   "bloc", "irq_poll", "tasklet", "sched", 
  "hrtime", "rcu", "", "",    "", "", "", ""
];

var errno_name = [
  "eperm", "enoent", "esrch", "eintr",   "eio", "enxio", "e2big", "enoexec", 
  "ebadf", "echild", "eagain", "enomem",   "eacces", "efault", "enotblk", "ebusy",
  "eexist", "exdev", "enodev", "enotdir",   "eisdir", "einval", "enfile", "emfile",
  "enotty", "etxtbsy", "efbig", "enospc",   "espipe", "erofs", "emlink", "epipe",
  "edom", "erange", "edeadlk", "enametoolong",   "enolck", "enosys", "enotempty", "eloop",
  "", "", "", "",   "", "", "", "", 
  "", "", "", "",   "", "", "", "", 
  "", "", "", "",   "", "", "", "", 
];

// Create full event name
function fullname(d, short) {
  var fulltext;
  if (short) {
    // Short form is name truncated to 8 chars, plus any (non-zero) arg
    fulltext = name(d);
    if (name(d).length > 8) {fulltext = name(d).substr(0, 6) + "~" + name(d).substr(name(d).length - 1, 1);}
    var arg = arg0(d);
    if (is_special(d) || is_irq(d)) {
      if (is_bottom_half(d)) {
        // For BH, map arg to a BH name
        // DEFUNCT rawtoevent does this now fulltext += "(" + soft_irq_name[arg & 0x0F] + ")";
      } else if (arg != 0) {
        // For others, give numeric argument
        fulltext += "(" + arg + ")";
      }
    } else if (is_syscall(d) && !is_sched_syscall(d)) {
      fulltext += "(" + arg + ")";
    }
  } else {
    // Long form is full name, plus any (non-zero) arg and retval
    fulltext = name(d);
    if (is_special(d) || is_irq(d)) {
      if (arg0(d) != 0) {
        fulltext += "(" + arg0(d) + ")";
      }
    } else if (is_syscall(d) && !is_sched_syscall(d)) {
      var rt = ret(d);
      // Map 16-bit truncated return value into -128..65408 so we can 
      //   see likely error codes -1..-128
      if (rt > (65536 - 128)) {
        // For "negative", map return value to an errno name
        fulltext += "(" + arg0(d) + ")=" + errno_name[(65535 - rt) & 0x3F];
      } else {
        fulltext += "(" + arg0(d) + ")=" + rt;
      }
    }
  }
  return fulltext;
}
 
// Rotate the annots within a row
function rotateRow(row, maxannot) {
    ++rowToLabelk[row];
    if (rowToLabelk[row] >= maxannot) {rowToLabelk[row] = 0;}

}


// Inputs per rowheight:
//  perTracksize[i].annotsize 	annotation font size
//  perTracksize[i].annotcount 	annotation font size
//  perTracksize[i].eventheight pix height for drawing events
//  perTracksize[i].annotheight pix height for drawing annotation text
//  perTracksize[i].eventoffset pix offset for event centerline
//  perTracksize[i].annotoffset pix offset for annot[0] text baseline

// Mark a time span with vertical line and text time/name/duration
// my is the mouse-click y-pixel or -1. If -1, draw at CPU row
// Return the x-coordinate in pixels 
function annotatespan(d, clss, short, my, rotate) {
//console.log("annotatespan", d, clss, short, rotate);
    rubberband = innersvgdotg.append("path")	// Placeholder objects
        .attr("class", "verticalline " + clss);
    rubberband2 = innersvgdotg.append("path")	// Placeholder objects
        .attr("class", "verticaldashline " + clss);

    // Pixel x-position for start of event
    var vx = x_zoomed(ts(d));	// time to pixel
    
    // Working toward pixel y-position via row
    var row;
    if (my < 0) {
      // No incoming click; find CPU row
      row = getrow(d, prefixCpu);
    } else {
      // Incoming click; find nearest row
      row = doSnap_y(my);
    }
    if (row < 0) {return;}

    var rowheight = rowToHeight[row];
    var rowtrack = rowToTrack[row];
    if (rowheight == 0) {return;}
//console.log("  track,height", rowtrack, rowheight);
//console.log("  annotation offset,height,count", 
//  perTracksize[rowheight].annotoffset, 
//  perTracksize[rowheight].annotsize,
//  perTracksize[rowheight].annotcount);
//console.log("  event offset,height", 
//  perTracksize[rowheight].eventoffset, 
//  perTracksize[rowheight].eventheight);

    var maxannot = perTracksize[rowheight].annotcount;
    if (maxannot <= 0) {return;}

    var annotheight = perTracksize[rowheight].annotsize;
    var y0 = y_zoomed(rowToTrack[row]);
    var vy = y0 + perTracksize[rowheight].annotoffset + rowToLabelk[row] * annotheight;
    
    // Rotate the annots within a row
    if (rotate) {rotateRow(row, maxannot);}

    // Create text string
    var timetxt = shortnum5(tsrel(d));
    var fulltext = fullname(d, short);
    if (!short) {
      // Long form includes start time and duration
      fulltext = timetxt + " " + fulltext + "; " + 
        shortnum(dur(d), data.thousandsX) + data.shortUnitsX;
      if (state.ipc_value >= 0) {	// available
        fulltext += " IPC=" + ipcvalues[ipc(d)];
      }
    } 
//console.log("text vx,y '", fulltext, "'", vx, vy);

    // Put something behind the string
    var xmid = Rnd1(vx + 4);
    var ymid = Rnd1(vy);
    var textwidth = Rnd1((fulltext.length + 1) * annotheight * 0.5);

    innersvgdotg.append("rect")
      .attr("class", "markertext " + clss)    
      .attr("x", (xmid - 2) + "px")       
      .attr("y", (ymid - annotheight * 0.8) + "px")       
      .attr("width", textwidth + "px")
      .attr("height", axisSmallTickPx)
      .attr("style", "fill:rgb(255,255,255); opacity:0.875"); 

    // Show the string
    innersvgdotg.append("text")	// Placeholder objects
      .attr("class", "markertext noselect " + clss)
      .attr("transform", "translate(" + (xmid) + "," + (ymid) + ")scale(1,1)")
      .attr("font-size", annotheight + "px")
      .text(fulltext);

    // Drop a vertical line down to region234height at item start
    var path = d3.path();
    path.moveTo(vx, y0 + perTracksize[rowheight].eventoffset + 
      0.55 * perTracksize[rowheight].eventheight);
    path.lineTo(vx, region234height);
    rubberband.attr("d", path);

    // Pop a vertical dashed line up to 4 (a little space under title) at item start
    var path2 = d3.path();
    path2.moveTo(vx, 4);
    path2.lineTo(vx, y0 + perTracksize[rowheight].eventoffset - 
      0.55 * perTracksize[rowheight].eventheight);
    rubberband2.attr("d", path2);
 
    return vx;
}
 
// If mouse is in Region2, go affect Y, else we are in Region3 and affecting X
// But if at far left 1/4 of region2, ignore here (shift-click label rotates compress) 
function inHilitePartOfRegion2(x) {
  if (0 <= x) {return false;}
  if (x < (-0.75 * region2width)) {return false;}
  return true;
}

// Mouse clicks on main SVG area come here. Those with 0 <= x affect Region3 and
// those with x < 0 affect Region2
function mousedown_x() {
console.log("mousedown_x");
    // If not shiftKey, pass it on
    if (!d3.event.shiftKey) {
      return;
    }
    d3.event.stopPropagation();

    // Accumulate rubberlines as long as shift-click
    //resetlines();
  
    var m = d3.mouse(this);
    mx1 = m[0];		// Remember so we can check for tiny movement in mousemove
    my1 = m[1];		// Remember so we can check for tiny movement in mousemove
console.log("mousedown at", mx1, my1);
    if (inHilitePartOfRegion2(mx1)) {mousedown_y(m); return;}

    var dx1 = x_zoomed.invert(mx1);	// time
    var dy1 = y_zoomed.invert(my1);	// track
console.log("mousedown_x at", dx1, dy1, "realxleft", realxleft);

    // Find nearest data object
    var i = FindNearestEvent(mx1, my1); 
    if (i < 0) {return;}

    d1 = data.events[i];
    // Draw and label vertical line at start of object
    var short = false;
    var rotate = true;
    vx1 = annotatespan(d1, "first", short, my1, rotate);

    state.annotated_d.push(i);
    // Always keep around the most recent explicit click
    state.annotated_one_d = i;
console.log("mousedown_x annotated_one_d=", state.annotated_one_d); 

   
    // Set up for possible drag
    //innersvgdotg.on("mousemove", mousemove_x);
    svgdotg.on("mousemove", mousemove_x);
}
 
// Rubber band shift-click-drag to see timespan
function mousemove_x() {
//console.log("mousemove_x");
    d3.event.stopPropagation();

    var m = d3.mouse(this);
    var mx2 = m[0];
    var my2 = m[1];

    var deltamx = Math.abs(mx1 - mx2);
    var deltamy = Math.abs(my1 - my2);
    if ((deltamx < 5) && (deltamy < 5)) {return;}	// Move at least 5 px
  
    // Remove any previous second line
    d3.selectAll(".second").remove();

    rubberband3 = innersvgdotg.append("path")	// Placeholder objects
        .attr("class", "rubberline second");

    // backmap mouse client pixels to pre-zoomed pixels
    var dx2 = x_zoomed.invert(mx2);
    var dy2 = y_zoomed.invert(my2);
//console.log("mousemove at", dx2, dy2);

    // Find nearest data object
    var i = FindNearestEvent(mx2, my2); 
    if (i < 0) {return;}

    d2 = data.events[i];
    // Draw and label vertical line at start of object
    var short = false;
    var rotate = false;
    vx2 = annotatespan(d2, "second", short, my2, rotate);

    // Make a path at the bottom and label it
    var path = d3.path();
    path.moveTo(vx1, region234height - 4);
    path.lineTo(vx2, region234height - 4);
    // Update the path placeholder
    rubberband3.attr("d", path);

    var deltax = Math.abs(ts(d1) - ts(d2)) * data.shortMulX;
    var deltatext = shortnum5(deltax);

    // Put something behind the delta so it is visible even if on top of timelines
    var xmid = Rnd1((vx1 + vx2) / 2);
    var ymid = Rnd1(region234height - 8);
    var textwidth = Rnd1((deltatext.length + 2) * textsize.smalltick * 0.5);

    innersvgdotg.append("rect")
      .attr("class", "rubberbackground second")    
      .attr("x", (xmid - textwidth / 2) + "px")       
      .attr("y", (ymid - textsize.smalltick * 0.9) + "px")       
      .attr("width", textwidth + "px")
      .attr("height", axisSmallTickPx)
      .attr("style", "fill:rgb(255,255,255); opacity:0.875"); 

    // Label the line
    rubbertextx = innersvgdotg.append("text")
        .attr("class", "markertext noselect second");
    rubbertextx
      .attr("transform", 
            "translate(" + (xmid) + "," + 
             (ymid) + ")scale(1,1)")
      .attr("font-size", axisSmallTickPx)
      .style("text-anchor", "middle")
      .text(deltatext);   
}
 
// Mouse clicks on main SVG area come here. Those with 0 <= x affect Region3 and
// those with x < 0 affect Region2
function mouseup_x() {
//console.log("mouseup_x");
    d3.event.stopPropagation();
    var m = d3.mouse(this);
    var mx = m[0];
    var my = m[1];
//console.log("mouseup_x at", mx, my);
    // If mouse is in Region2, go affect Y, else we are in Region3 and affecting X
    if (inHilitePartOfRegion2(mx)) {
      mouseup_y(m); 
      return;
    }

    ////innersvgdotg.on("mousemove", null);
    svgdotg.on("mousemove", null);
    // If shift key is still down, remove all rubberlines and clear annots
    if (d3.event.shiftKey) {
      resetlines();
      state.annotated_d = [];
      state.annotated_one_d = -1;
    }
}

// For input event d, apply ff to each cpu, pid, rpc, res field
function applyevent(d, i, ff, arg) {
  if (0 <= cpu(d)) {ff(arg, d, i, prefixCpu, low16of(cpu(d)));}
  if (0 < pid(d))  {ff(arg, d, i, prefixPid, low16of(cpu(d)));}
  if (0 < rpc(d))  {ff(arg, d, i, prefixRpc, low16of(cpu(d)));}
  if (0 <= res(d)) {ff(arg, d, i, prefixRes, low16of(cpu(d)));}
}

function getrow_cpu2(d, prefix) {
  if ((prefix == prefixCpu) && (0 <= cpu2(d))) {
    return eventToRow[prefix * 65536 + low16of(cpu2(d))];
  }
  return -1;
}

function getrow(d, prefix) {
  if ((prefix == prefixCpu) && (0 <= cpu(d))) {
    return eventToRow[prefix * 65536 + low16of(cpu(d))];
  }
  if ((prefix == prefixPid) && (0 < pid(d))) {
    return eventToRow[prefix * 65536 + low16of(pid(d))];
  }
  if ((prefix == prefixRpc) && (0 < rpc(d))) {
    return eventToRow[prefix * 65536 + low16of(rpc(d))];
  }
  if ((prefix == prefixRes) && (0 <= res(d))) {
    return eventToRow[prefix * 65536 + low16of(res(d))];
  }
  return -1;
}

// Highlight any event in hilite_row, and set full-size row for all its copies
function ffHiliteEvent(d, i, hilite_row) {
  var keep = is_kernelusermark(d) || is_arc(d);
  if (!keep) {return;}
  var cpurow = getrow(d, prefixCpu);
  var pidrow = getrow(d, prefixPid);
  var rpcrow = getrow(d, prefixRpc);
  var resrow = getrow(d, prefixRes);
  if ((cpurow == hilite_row) || 
      (pidrow == hilite_row) || 
      (rpcrow == hilite_row) || 
      (resrow == hilite_row)) {
    state.hilite_event_set.add(i);
    if(0 <= cpurow) {state.fullsize_row_set.add(cpurow);}
    if(0 <= pidrow) {state.fullsize_row_set.add(pidrow);}
    if(0 <= rpcrow) {state.fullsize_row_set.add(rpcrow);}
    if(0 <= resrow) {state.fullsize_row_set.add(resrow);}
  }
  // Highlight arc if either end is highlighted
  if (is_arc(d)) {
    var cpurow2 = getrow_cpu2(d, prefixCpu);
    if (cpurow2 == hilite_row)  {state.hilite_event_set.add(i);}
  }
}

 
// m has mouse pixel coordinates [x,y]
function mousedown_y(m) {
//console.log("mousedown_y");
  // If not shiftKey, pass it on
  if (!d3.event.shiftKey) {
    return;
  }
  d3.event.stopPropagation();

  // Backmap and turn on highlights here
  var hilite_row = doSnap_y(m[1]);
//console.log("  hilite_row", hilite_row, sortName[hilite_row]);
  state.hilite_row_set.add(hilite_row);

  // scan events array and for all onscreen and in this row, add those 
  // events to hilite_event_set and *each* of their rows to hilite_row_set
  for (var i = 0; i < data.events.length; ++i) {
    var d = data.events[i];
    ffHiliteEvent(d, i, hilite_row);
  }
//console.log("hilite_event_set", state.hilite_event_set);
//console.log("hilite_row_set", state.hilite_row_set);

  updateTracks();
  y.domain([0, maxTrack]);
  resetRangeDomain();
  calcPixHeightsPerTrack(ypixpertrack);

  redrawEventsEtc();
  redrawYlabels();

}
 
// m has mouse pixel coordinates;
function mouseup_y(m) {
//console.log("mouseup_y");
  // If shift key is still down, remove all highlights
  if (d3.event.shiftKey) {
    state.hilite_event_set.clear();
    state.hilite_row_set.clear();
    state.fullsize_row_set.clear();
//console.log("hilite erased");
  }
  d3.event.stopPropagation();

  updateTracks();
  y.domain([0, maxTrack]);
  resetRangeDomain();
  calcPixHeightsPerTrack(ypixpertrack);

  redrawEventsEtc();
  redrawYlabels();

}

//BUG: after save, gray goes away
 
 
// Inputs: 
// winWidth and winHeight, which either come from window.innerWidth/Height
//   or from one of the reset buttons.
// sortNumSize from the number of rows to display
//
// For reasons that don't make much sense, I decided to tile this area in rectangles
// that are multiples of 120x160 pixels, with a minimum of 2x2 such rectangles. This 
// lends itself to onscreen pictures that have a little bit of reproducible sizes.
//
// Much of the spacing and text sizing is based on the number of such tiles, so they 
// adjust within limits as the browser window changes size.

// There are four text sizes, chosen emperically:
//  title, used for top title:           for tiles [2..12], range is [16..96] pixels
//  label, used for X and Y axis labels: for tiles [2..12], range is [10..60] pixels
//  tick, used for axis values:          for tiles [2..12], range is [9..42] pixels
//  smalltick, used for annotations:     for tiles [2..12], range is [9..15] pixels
//
// Within the window, these margins are first reserved for borders and the top buttons 
//  winMargin: width=10px height=40px
//
// Within the remaining window, these drawing margins are reserved
//  top:    title + 3
//  left:   label + 3 + 5_chars * tick + 6 (assumes char width is 0.6 tick)
//  right:  5_chars * tick
//  bottom: 2 * tick + label * 1.25 + 6
//
// The active area for the diagram, sans title, axes, labels is
//  width: (winWidth/160) * 160 - margin.left - margin.right - winMargin.width 
//  height: (winHeight/120) * 120 - margin.top - margin.bottom - winMargin.height;
//
// The main SVG area is allocated around the active area with [0,0] at [left, top] and  
//  SVG width:  (winWidth/160) * 160  - winMargin.width
//  SVG height: (winHeight/120) * 120 - winMargin.height
// and within this SVG area the diagram height is SVG hight bounded by
//  60px * (sortNumSize + 1.5)
// so that the CPU rtracks are not excessively spaced out if drawn in a tall window.
//
// With the outer SVG area there is a group, svgdotg, with origin also at [left, top]
//
// Within this group is an inner SVG area 
//  inner width:  SVG width - margin.left, allowing drawing into margin.right
//  inner height: SVG height
//
// And finally...
// With the inner SVG area there is a group, innersvgdotg, and all the real drawing is
// put within this group.
// 
 
 
function myFilter() {
  return !d3.event.shiftKey;	// FIREFOX event is not defined
}


// Return outermost outline, grey for kernel
function l4color(d, gray) {
  if (is_fault(d)) {return "#FFFFFF";}
  if (is_irq(d)) {return gray ? "#808080" : "#000000";}
  if (is_syscall(d)) {return gray ? "#C0C0C0" :"#808080";}
  return"#55AA55";
}
function l3color(d, gray) {
  if (is_kernel(d)) {
    if (gray) {return kernelgray[ev(d) >> 8];}
    return kernelcolor[ev(d) >> 8];
  }
  return"#FFFFFF";
}
// For deferred events only
function l3darkcolor(d, gray) {
  if (is_kernel(d)) {
    if (gray) {return darkkernelgray[ev(d) >> 8];}
    return darkkernelcolor[ev(d) >> 8];
  }
  return"#FFFFFF";
}

// The multiplies keep the colors for n and n+1 somewhat uncorrelated
// The plus keeps the colors for 0 somewhat apart
function l2colorx(d, gray) {
  if (is_idle(d)) {return "#FFFFFF";}
  if (gray) {return state.currentcolor.gray2[(ev(d) * 4) % state.currentcolor.mod2];}
  return state.currentcolor.color2[(ev(d) * 4) % state.currentcolor.mod2];
}

function l1colorx(d, gray) {
  if (is_idle(d)) {return gray ? "#808080" : "#000000";}
  if (gray) {return state.currentcolor.gray1[(ev(d) * 5 + 6) % state.currentcolor.mod1];}
  return state.currentcolor.color1[(ev(d) * 5 + 6) % state.currentcolor.mod1];
}

// The multiplies keep the colors for n and n+1 somewhat uncorrelated
// The plus keeps the colors for 0 somewhat apart
function l2color(d, gray) {
  if (is_idle(d)) {return "#FFFFFF";}
  if (gray) {return state.currentcolor.gray1[(ev(d) * 4) % state.currentcolor.mod1];}
  return state.currentcolor.color1[(ev(d) * 4) % state.currentcolor.mod1];
}

function l1color(d, gray) {
  if (is_idle(d)) {return gray ? "#808080" : "#000000";}
  if (gray) {return state.currentcolor.gray2[(ev(d) * 5 + 6) % state.currentcolor.mod2];}
  return state.currentcolor.color2[(ev(d) * 5 + 6) % state.currentcolor.mod2];
}

function l0color(d, gray) {
  if (is_idle(d)) {return gray ? "#808080" : "#000000";}
  return color64_0[(ev(d) * 9) % 64];
}



// This is where the ratings below came from historically
// Proportions   k4 : 30, k3 : 28, k2 : 16, k1 : 6,  
//                   1.00     0.93     0.53     0.20
//                       idle : 2, u2 : 12, u1 : 8
//                            0.07     0.40     0.27
// Newer:
//  linewidth.k3 = Math.round(linewidth.k4 - 2);	0.93
//  linewidth.k2 = Math.round(linewidth.k3 * 4 / 7);	0.53
//  linewidth.k1 = Math.round(linewidth.k2 * 3 / 8);	0.20
//  linewidth.u2 = Math.round(linewidth.k4 * 1 / 4);	0.23
//  linewidth.u1 = Math.round(linewidth.u2 * 2 / 3);	0.15
//  linewidth.idle = Math.round(linewidth.k4 / 15);	0.07


function l4width(d, eventheight) {
  if (is_kernel(d)) {return Rnd1(1.00 * eventheight);}
  return 0;
}
function l3width(d, eventheight) {
  if (is_kernel(d)) {return Rnd1(0.93 * eventheight);}
  return 0;
}
function l2width(d, eventheight) {
  if (is_idle(d)) {return 0;}
  if (is_kernel(d)) {return Rnd1(0.53 * eventheight);}
  return Rnd1(0.23 * eventheight);
}
function l1width(d, eventheight) {
  if (is_idle(d)) {return Rnd1(0.07 * eventheight);}
  if (is_kernel(d)) {return Rnd1(0.20 * eventheight);}
  return Rnd1(0.15 * eventheight);
}


// Set up the initial scaling for X-axis and Y-axis
function setInitialRangeDomain() {
console.log("setInitialRangeDomain", dataTsLo, dataTsHi, 0, sortNumSize); 
  // Set the scales and ranges
  // Initialize the left and right values
  state.savedtransformX = d3.zoomIdentity;
  state.savedtransformY = d3.zoomIdentity;

//console.log("***** initial state.savedtransformY", state.savedtransformY);


  // To keep circles all visible within the svg clipping rectangle, 
  // we need ~5px of padding around the range
  x = d3.scaleLinear()
      .range([axesmargin, region3width - axesmargin])
      .nice(10);
  x.domain([dataTsLo, dataTsHi]);

  // Zoomed version of x scale above
  x_zoomed = state.savedtransformX.rescaleX(x);

  // Initial X-axis bounds just after data load, before any pan/zoom
  reset_globals_x(dataTsLo, dataTsHi, dataTsHi);

  y = d3.scaleLinear()
      .range([axesmargin, region234height - axesmargin])
      .nice(sortNumSize);
  y.domain([0, maxTrack]);	// N tracks

  // Zoomed version of x scale above
  y_zoomed = state.savedtransformY.rescaleY(y);

  // Initial Y-axis bounds just after data load, before any pan/zoom
  reset_globals_y(0, maxTrack);
}


// Set up the scaling for X-axis and Y-axis after zoom/pan of either
function resetRangeDomain() {
//console.log("resetRangeDomain");

  // Zoomed version of x scale above
  x_zoomed = state.savedtransformX.rescaleX(x);

//console.log("resetRangeDomain state.savedtransformX", state.savedtransformX);


  // New X-axis bounds
  resetonscreen_x();

  // Zoomed version of x scale above
  y_zoomed = state.savedtransformY.rescaleY(y);

//console.log("y_zoomed.domain", y_zoomed.domain());
//console.log("y_zoomed.range", y_zoomed.range());


  // New Y-axis bounds 
  resetonscreen_y();
}


function calculateRowTracks() {
}


// To keep the display digits manageable for the X-axis, we want to remove 
// all the common leading time and display it once as basetime.
// To do this, we first converted the incoming data.tracebase string,
//  2016-11-19_10:04:00
// to numeric seconds 0..86400
//
// Set up x zoom and call resetonscreen_x before calling this
function calculateBasetime() {
  // Current X-axis ranges from realxleft to realxright seconds from
  // dataBaseSecond
  var xaxisspan = realxright - realxleft;	// seconds
//console.log("calculateBasetime", dataBaseSecond , realxleft, realxright, xaxisspan);
 
  // We want offsets in seconds from the base seconds, no hh:mm
  var baseleft = realxleft;
  var fullbaseleft = dataBaseSecond + baseleft;
  var secfmt = "02d";

  if (60 <= xaxisspan) {
    xaxisfmt.basetime = (Math.floor(fullbaseleft / 3600) * 3600) - dataBaseSecond;	
    // Hour hh:00:00 with multiple of 10, 100, 1000 seconds shown as mm:ss
    xaxisfmt.deltamul = 0;
    xaxisfmt.deltamax = 60;
    xaxisfmt.ovflnext = Math.floor(fullbaseleft / 3600 + 1) % 60;
    xaxisfmt.ovflformat = "02d"; 
    xaxisfmt.deltaformat = "05.2f";
    document.getElementById("xaxislabel").innerHTML = "Time (mm:ss)";
  } else if (1.0 <= xaxisspan) {
    // Minute hh:mm:00
    xaxisfmt.basetime = Math.floor(fullbaseleft / 60) * 60 - dataBaseSecond;		
    xaxisfmt.deltamul = 1;
    xaxisfmt.deltamax = 60;
    xaxisfmt.ovflnext = Math.floor(fullbaseleft / 60 + 1) % 60;
    xaxisfmt.ovflformat = "02d"; 
    xaxisfmt.deltaformat = "04.1f";
    document.getElementById("xaxislabel").innerHTML = "Time (sec)";
  } else if (0.001 <= xaxisspan) {
    xaxisfmt.basetime = Math.floor(baseleft);			// Second hh:mm:ss	
    xaxisfmt.deltamul = 1000; 	
    xaxisfmt.deltamax = 1000;
    xaxisfmt.ovflnext = Math.floor(fullbaseleft + 1) % 60;
    xaxisfmt.ovflformat = "02d"; 
    xaxisfmt.deltaformat = "05.1f";
    if (0.010 <= xaxisspan) {xaxisfmt.deltaformat = "03d";}
    document.getElementById("xaxislabel").innerHTML = "Time (msec)";
  } else if (0.000001 <= xaxisspan) {
    xaxisfmt.basetime = Math.floor(baseleft * 1000) / 1000;	// Msec hh:mm:ss.mmm
    secfmt = "06.3f";
    xaxisfmt.deltamul = 1000000;
    xaxisfmt.deltamax = 1000;
    xaxisfmt.ovflnext = Math.floor(baseleft * 1000 + 1) % 1000;
    xaxisfmt.ovflformat = "03d"; 
    xaxisfmt.deltaformat = "05.1f";
    if (0.000010 <= xaxisspan) {xaxisfmt.deltaformat = "03d";}
    document.getElementById("xaxislabel").innerHTML = "Time (usec)";
  } else {
    xaxisfmt.basetime = Math.floor(baseleft * 1000000) / 1000000; // Usec hh:mm:ss.uuuuuu
    secfmt = "09.6f";
    xaxisfmt.deltamul = 1000000000;
    xaxisfmt.deltamax = 1000;
    xaxisfmt.ovflnext = Math.floor(baseleft * 1000000 + 1) % 1000;
    xaxisfmt.ovflformat = "03d"; 
    xaxisfmt.deltaformat = "05.1f"; 	
    if (0.000000010 <= xaxisspan) {xaxisfmt.deltaformat = "03d";}
    document.getElementById("xaxislabel").innerHTML = "Time (nsec)";
  }
  document.getElementById("basetimetext").innerHTML = 
    dataBaseDate + " " + hhmmss(dataBaseSecond + xaxisfmt.basetime, secfmt);

//console.log("basetime=", hhmmss(xaxisfmt.basetime, secfmt));
}

// Create and draw initial X-axis
function drawInitialXaxis() {
//console.log("drawInitialXaxis");

  // Define axes using scales x and y
  // This draws below Region3
  xAxis = d3.axisBottom(x)
          .ticks(10)
          .tickSize(4)
          .tickPadding(2)
          .tickFormat(shortxtime);
  xGrid = d3.axisBottom(x)
          .ticks(10)
          .tickSize(-region234height)
          .tickFormat(function() { return null; });

  // Add the x Axis group and draw the X-axis
  gX = svgdotg.append("g")
      .attr("class", "axis axis--x")
      .attr("transform", "translate(0," + region234height + ")")
      .call(xAxis);
  d3.selectAll(".tick")
    .attr("class", "tick noselect")
    .attr("className", "tick noselect")
    .style("font-size", axisSmallTickPx);

  // Put the grid on top
  // This draws on top of Region3 (after drawing events/marks/ipc)
  gXgrid = svgdotg.append("g")
    .attr("class", "axis--grid")
    .attr("transform", "translate(0," + region234height + ")")
    .call(xGrid);
  gXgrid.selectAll(".axis--grid line")  // select all the line elements for the grid
          .attr("style", "stroke-width:1px; fill:none; stroke:#F0F0F0");
  gXgrid.select(".domain").remove();	// Avoid drawing endpoint lines

  // Text label for the entire X axis is updated in calculateBasetime
}

// Create and draw initial Y-axis
// Degenerate form -- just to get the domain line
function drawInitialYaxis() {
//console.log("drawInitialYaxis");
  // This draws to the left of Region3
  //yAxis = d3.axisLeft(y).ticks(sortNumSize + 1);
  yAxis = d3.axisLeft(y).ticks(0).tickSize(4);

  // Add the y Axis group
  gY = svgdotg.append("g")
      .attr("class", "axis axis--y")
      .call(yAxis);
  d3.selectAll(".tick")
    .attr("class", "tick noselect")
    .attr("className", "tick noselect")
    .style("font-size", axisSmallTickPx);

  // Text label for the entire Y axis
//  svgdotg.append("text")
//      .attr("transform", "rotate(-90)")
//      .attr("class", "axis-text noselect")
//      .attr("font-size", (textsize.label) + "px")
//      .style("fill", "blue")
//      .attr("y", 0 - region2width)
//      .attr("x", 0 - (region234height / 2))
//      .attr("dy", "0.9em")
//      .style("text-anchor", "middle")
//      .text(data.axisLabelY);   
}

// Redraw the zoomed X-axis and grid
function redrawXaxis() {
  gX.call(xAxis.scale(x_zoomed));

  d3.selectAll(".tick")
    .attr("class", "tick noselect")
    .attr("className", "tick noselect")
    .style("font-size", axisSmallTickPx);

  gXgrid.call(xGrid.scale(x_zoomed));
  gXgrid.selectAll(".axis--grid line")  // select all the new grid line elements
          .attr("style", "stroke-width:1px; fill:none; stroke:#F0F0F0");
  gXgrid.select(".domain").remove();	// Avoid drawing endpoint lines
  // Text label for the entire X axis is updated in calculateBasetime
}


// Redraw the zoomed Y-axis 
function redrawYaxis() {
//console.log("redrawYaxis");
  gY.call(yAxis.scale(y_zoomed));
  d3.selectAll(".tick")
    .attr("class", "tick noselect")
    .attr("className", "tick noselect")
    .style("font-size", axisSmallTickPx);
  // Text label for the entire Y axis is unchanged
}

// BLACK RIGHT-POINTING TRIANGLE (U+25B6)
// BLACK DOWN-POINTING TRIANGLE (U+25BC)
// Show arrow for Y-axis group name
function expandArrow(prefix) {
  return (state.groupcompress[prefix] == 0) ? "\u25B6" : "\u25BC"; 
}

function drawLabel(row, fontsize) {
  if (rowToHeight[row] == 0) {return;}
  var off = perTracksize[rowToHeight[row]].eventoffset;
  var y0 = y_zoomed(rowToTrack[row]) + off;
  var labelypos = y0 + 0.4 * fontsize;

  var labelid = "labeltext";
  var labelxpos = region2width - 6;
  var labelanchor = "end";
  var labelweight = "normal";
  var labelfill = "black";
  var labeltext = sortName[row];
  var is_group_label = (sortNum[row] < 0);
  if (is_group_label) {
    // Left-justify group names
    var prefix = -sortNum[row] - 1;
    state.grouplabelypos[prefix] = labelypos;
    labelid += (prefix);	// "labeltext0", labeltext1", etc.
    labelxpos = 0;
    labelanchor = "start";
    labelweight = "bold";
    // Light gray group label if no items, else blue
    labelfill = state.grouplength[prefix] == 0 ? "#c0c0c0" : "blue";
    labeltext = expandArrow(prefix) + " " + sortName[row] + 
      " (" + state.grouplength[prefix] + ")"; 
  } else {
    // Bold labels for shift-click explicitly-highlighted rows
    if (rowHilite(row)) {labelweight = "bold";}
  }
 
  var label = region2dotg.append("text") 
      .attr("id", labelid) 
      .attr("class", "labeltext noselect")           
      .attr("transform", "translate(" + (labelxpos) + ", " +
            (labelypos) + ")")
      .attr("width", region2width)
      .attr("font-size", fontsize + "px")
      .attr("font-family", "sans-serif")
      .attr("font-weight", labelweight)
      .style("text-anchor", labelanchor)
      .style("fill", labelfill)
      .text(labeltext);

  // Tick mark
  if (! is_group_label ) {
    var path = "M" + Rnd1(region2width) + "," + Rnd1(y0) + " h-4";
    region2dotg.append("path")
      .attr("class", "labeltick")
      .attr("d",  path)
      .attr("stroke-width", "1")	
      .attr("stroke", "#000000");		// black
  }
}


// Redraw the zoomed Y-axis 
function redrawYlabels() {
//console.log("redrawYlabels");
  d3.selectAll("#labeltext").remove();
  d3.selectAll("#labeltext0").remove();
  d3.selectAll("#labeltext1").remove();
  d3.selectAll("#labeltext2").remove();
  d3.selectAll("#labeltext3").remove();
  d3.selectAll(".labeltick").remove();

  // Y-axis line
//  var path1 = "M" + Rnd1(region2width - 0.5) + "," + (axesmargin) + " h-4 h4" +
//             " v" + (region234height - 2 * axesmargin) +
//             " h-12 h12";
//  region2dotg.append("path")
//    .attr("class", "labeltick")
//    .attr("d",  path1)
//    .attr("stroke-width", "1")	
//    .attr("stroke", "#000000");		// black

  for (var row = 0; row < sortNumSize; ++row) {
    drawLabel(row, textsize.smalltick );
  }

  if (state.grouplength[prefixCpu] > 0) {
    document.getElementById("labeltext0").addEventListener("click", doToggleCompress0);
  }
  if (state.grouplength[prefixPid] > 0) {
    document.getElementById("labeltext1").addEventListener("click", doToggleCompress1);
  }
  if (state.grouplength[prefixRpc] > 0) {
    document.getElementById("labeltext2").addEventListener("click", doToggleCompress2);
  }
  if (state.grouplength[prefixRes] > 0) {
    document.getElementById("labeltext3").addEventListener("click", doToggleCompress3);
  }

}



function drawInitialPanZoom() {
  // Last, add the rectangle we anchor the zoom action to
  // If we add it earlier, we can't zoom if exactly over the line or dots
  // This draws on top of Region3 
  panzoomrect_x = svgdotg.append("rect")
    .attr("id", "panzoomrect_x")    
    .attr("x", axesmargin)       
    .attr("width", region3width - axesmargin)
    .attr("height", region234height + region5height/2)
    .attr("style", "fill:rgb(255,240,255); opacity:0");	// Transparent. 0=>0.5 to make visible

  // Define a zoom, no attach, no draw; define watcher
  // Initializes with zoomIdentity
  myZoom_x = d3.zoom()
    .filter(myFilter)
    .on("zoom", do_zoomed_x);
 
  // Apply zoom function to entire inner rectangle; sets watcher
  panzoomrect_x.call(myZoom_x);     // This just enables on the rect itself, passive


  panzoomrect_y = svgdotg.append("rect")
    .attr("x", -(0.75 * region2width))
    .attr("id", "panzoomrect_y")            
    .attr("width", 0.75 * region2width)
    .attr("height", region234height - axesmargin)
    .attr("style", "fill:rgb(255,255,240); opacity:0"); // Transparent. 0=>0.5 to make visible


  // Define a zoom, no attach, no draw; define watcher
  // Initializes with zoomIdentity
  myZoom_y = d3.zoom()
    .filter(myFilter)
    .on("zoom", do_zoomed_y);
 
  // Apply zoom function to entire inner rectangle; sets watcher
  panzoomrect_y.call(myZoom_y);     // This just enables on the rect itself, passive

}

function redrawPanZoom() {
}

function resetDefer(row) {
  defer_dur_i[row] = 0; 
  defer_dur_u[row] = 0; 
  defer_dur_k[row] = 0; 
  defer_dur[row] = 0; 
  defer_event_u[row] = 0;
  defer_event_k[row] = 0;
}

function initializeDrawingState() {
  // Initialize deferred
  for (var row = 0; row < sortNumSize; ++row) {
    resetDefer(row);
    highwater_mark[row] = 0;
    rowToLabelk[row] = 0;		// Rotate event labels separately for each row
    rightmostnum[row] = 0;		// Spread apart mark_d numbers
  }
}

function redrawEvents() {
  //console.log("redrawEvents");

  // Draw all the rectangles
  fastdrawevents();
}


// Called when starting all over with new window size
// Outer and inner SVGs exist but are empty
//
// Order of drawing:
//  +Set x and y domain & range
//  Calculate row height and tracks
//  Calculate basetime
//
//  Draw all the events in region3
//  Draw marks
//  Draw IPC
//
//  Draw Y-axis in region2
//  Draw X-axis in region5
//  Draw grid in region3
//
//  Draw scroll in region3
//  Draw scroll in region2
//
// Remove and reset annotations, calc X and Y scaling, draw events, draw IPC legend
// Set up x zoom and call resetonscreen_x before calling this
// Do this before drawing axes, which depend on calculateBasetime
function redrawEventsEtc() {
  //console.log("redrawEventsEtc", data.events.length, "events");

  resetlines();
  resetRotatingLabelk();

  // Calculate per-row track height and position
  calculateRowTracks();

  // Calculate and display basetime
  calculateBasetime();

  // Draw all events onscreen, plus marks, plus IPC
  redrawEvents();

  // If there is a previous single annotation and it is onscreen, draw it
  if (state.annotated_one_d != -1) {
    // Put just it into annotated list so that further pan/zoom finds it
    state.annotated_d = [];
    state.annotated_d.push(state.annotated_one_d);  // Keep
    var d = data.events[state.annotated_one_d];
    if (startsonscreen_x(d)) {
      var short = false;
      var rotate = false;
      annotatespan(d, "first", short, -1, rotate)
    }
  }

  // Draw IPC legend (possibly overlays events)
  redrawIpcLegend();

  // redrawMarks();

};
 
// Draw axes and labels and pan/zoom overlays, reset X and Y bounds
function drawInitialAxes() {
  // Draw X-axis and grid
  drawInitialXaxis();

  // Draw Y-axis labels
  drawInitialYaxis();
  redrawYlabels();

  // Draw pan/zoom overlays
  redrawPanZoom();
} 



//========
// Routines for initialization 


// fraction3 is [percentage, minimum, maximum]
function calcfraction(total, fraction3) {
  var temp = Math.round(total * fraction3[0] / 100);
  if (fraction3[1] != 0) {temp = Math.max(temp, fraction3[1]);}
  if (fraction3[2] != 0) {temp = Math.min (temp, fraction3[2]);}
  return temp;
}



function allocOuterSvg() {
  winWidth = window.innerWidth;
  winHeight = window.innerHeight;
  var txtmul = textmultiplier_tbl[state.textmultiplier_value];

  // Leave approximate room for Regions 0 and 6 (HTML lines)
  svgWidth = winWidth - (winMargin2.left + winMargin2.right);
  svgHeight = winHeight - (winMargin2.top + winMargin2.bottom);
  if (winWidth < winMargin2.width1) {
    // Make room for two lines at top and two at bottom if narrow window
    svgHeight = winHeight - (winMargin2.top2x + winMargin2.bottom2x);
  }
console.log("winWidth", winWidth, "winHeight", winHeight);
console.log("svgWidth", svgWidth, "svgHeight", svgHeight);

  // TEMP: Running comment
  document.getElementById("matchcount").innerHTML = svgWidth + "x" + svgHeight;

  // Remove any existing outersvg and all its contents
  d3.select("svg").remove() ;
 
  // Allocate new one
  outersvg = d3.select("span#anchorsvg").append("svg")
    .attr("class", "svgtop")
    .attr("width", svgWidth)
    .attr("height", svgHeight);

  // For tall narrow windows, scale labels by width, not height
  var tempheight = Math.min(svgHeight, svgWidth);
  region1height = Rnd0(txtmul * calcfraction(tempheight, region1paramH));
  region5height = Rnd0(txtmul * calcfraction(tempheight, region5paramH));
  region234height = svgHeight - region1height - region5height; 
console.log("region 1 234 5 heights =", region1height, region234height, region5height);

  // region1width = svgWidth;
  region2width = Rnd0(txtmul * calcfraction(svgWidth, region2paramW));
  region4width = Rnd0(calcfraction(svgWidth, region4paramW));
  region3width = svgWidth - region2width - region4width; 
  // Allow some slop room for labels and timelines to hang out into region4
  region3clipwidth = region3width + (region4width / 2); 
  // region5width = svgWidth;
console.log("region 2 3 4 widths =", region2width, region3width, region4width);

  // Set up matching text sizes
  // Title text size is 0.9 * region1height, which in turn is function of textmultiplier 
  // X-axis text size is 0.9 * region5height / 2
  // Small X-axis text size is 0.75 * region5height / 2
  // Annotation text size is ... Figure 16 CPU lines + 4 group labels + 1 or so = 21
  //  lines in 80% of the height, so each line is about 4% of the height
  //  we want lines of small text to fit into half this 

  textsize.title = Rnd0(0.9 * region1height);
  textsize.label = Rnd0(0.9 * region5height / 2);
  textsize.tick  = Rnd0(0.75 * region5height / 2);
  textsize.smalltick = Rnd0(0.55 * region5height / 2);

  titlePx =  textsize.title + "px";
  axisLabelPx =  textsize.label + "px";
  axisTickPx =  textsize.tick + "px";
  axisSmallTickPx = textsize.smalltick + "px";

  // TEMP show outer SVG with very light green
  //outersvg.append("rect")
  //  .attr("width", "100%")
  //  .attr("height", "100%")
  //  .attr("fill", "#FFFFF8");	// very light yellow

  // TEMP: Show the origin with (quarter) green circle
  //outersvg.append("circle")
  //  .attr("cx", 0)
  //  .attr("cy", 0)
  //  .attr("r", 7)
  //  .attr("fill", "green");
//console.log("  green circle should be showing");

  // The outer SVG has an offset group to contain all its children
  svgdotg =  outersvg.append("g")
    .on("mousedown", mousedown_x)
    .on("mouseup", mouseup_x)
    .attr("class", "svgdotg")
    .attr("transform", "translate(" + region2width + "," + region1height + ")");

  // And within outer, the inner SVG, aka Region 3
  innersvg = svgdotg.append("svg")
   .attr("class", "region3")
    .attr("width", region3clipwidth)  // Allow room for labels to hang out right
    ////.attr("width", region3width)  
    .attr("height", region234height);

  // And that inner SVG has a group to contain all its children
  // We catch mouse events in it also, for annotate
  innersvgdotg = innersvg.append("g");

  // TEMP: show innersvg with light red/gray
  innersvgdotg.append("rect")
    .attr("width", region3width)
    .attr("height", region234height)
    .attr("fill", "#FFFFFF");	// light red/gray


  // And within outer, an SVG area for Region 2
  region2 = svgdotg.append("svg")	// We want clipping to this rectangle
    .attr("class", "region2")
    .attr("x", -region2width)
    .attr("y", 0)
    .attr("width", region2width)
    .attr("height", region234height);

 // And within that, a group for Region 2
  region2dotg = region2.append("g"); 


  // And within outer, a group for Region 4
  region4 = svgdotg.append("g")
    .attr("class", "region4")
    .attr("x", region3width)
    .attr("y", 0)
//    .attr("fill", "#FFE0FF")		// TEMP magenta (change "g" to "rect" to see)
    .attr("width", region4width)
    .attr("height", region234height);

  // And within outer, a group for Region 5
  region5 = svgdotg.append("g")
    .attr("class", "region5")
    .attr("x",  -region2width)
    .attr("y", region234height)
//    .attr("fill", "#FFFFE0")		// TEMP yellow (change "g" to "rect" to see)
    .attr("width", svgWidth)
    .attr("height", region5height);

  // Show the base point in red (green if colorblind toggle is 1)
  reddot = svgdotg.append("circle")
    .attr("id", "reddot")
           .attr("cx", 0)
           .attr("cy", region234height)
           .attr("r", 7)
           .attr("fill", "red");
  // Set listener for red dot
  reddot.on("click", resetzoom);

//console.log("  red circle should be showing");
}

// Button is unavailable if val < 0
// Button is inactive if val == 0
// Button is active if val >= 0
function decorateButton(elem, val) {
  if (val > 0) {
    // active
    elem.style="background-color: rgb(240,240,255); color: rgb(0,0,0); border-color: rgb(0,0,255); border-radius:6px";
  } else if (val == 0) {
    // inactive
    elem.style="background-color: rgb(255,255,255); color: rgb(0,0,0); border-color: rgb(192,192,192); border-radius:6px";
  } else {
    // unavailable
    elem.style="background-color: rgb(255,255,255); color: rgb(224,224,224); border-color: rgb(224,224,224); border-radius:6px";
  }
}

// Save is active if val == true
function decorateSave(elem, val) {
 if (val) {
    // active
    elem.style="fill: rgb(0,0,0); font-weight: bold; color:black; font-size:24px;";
  } else {
    // inactive
    elem.style="fill: rgb(128,128,128); color:gray; font-size:24px;";
  }
}

// Save is active if val == true
function decorateMore(elem, val) {
 if (val) {
    // active
    elem.style="fill: rgb(0,0,0); font-weight: bold; color:black; font-size:12px;";
  } else {
    // inactive
    elem.style="fill: rgb(128,128,128); color:gray; font-size:12px;";
  }
}

// Flip reddot to cyan if color-blind is set
function decorateDot(elem, val) {
 if (val) {
    elem.style="fill: rgb(0,255,255);";
  } else {
    elem.style="fill: rgb(255,0,0);";
  }
}

function resetText(elem, val) {
  elem.value = val;
  if (IsActiveText(val)) {elem.style.backgroundColor= kActiveBackColor;}
  else                   {elem.style.backgroundColor= kInactiveBackColor;}
}

// Fill in UI text and buttons entirely from current state
// Must be called after fillOuterSvg establishes save0text, etc.
function redrawUI() {
  resetText(document.getElementById("FileName"), state.filename_text);
  resetText(document.getElementById("SearchText"), state.search_text);
  resetText(document.getElementById("SearchMin"), state.usec_lo_text);
  resetText(document.getElementById("SearchMax"), state.usec_hi_text);

  // TEMP commented out to let my debug info show through
  // document.getElementById("matchcount").innerHTML = "";

  decorateButton(document.getElementById("showcb"), state.cb_value);
  decorateButton(document.getElementById("showipc"), state.ipc_value);
  decorateButton(document.getElementById("showmarks"), state.marks_value);
  decorateButton(document.getElementById("showarcs"), state.arcs_value);
  decorateButton(document.getElementById("annotateall"), state.annotateall_value);
  decorateButton(document.getElementById("annotateuser"), state.annotateuser_value);
  decorateButton(document.getElementById("searchnot"), state.searchnot_value);

  decorateSave(document.getElementById("save0text"), saved_valid[0]);
  decorateSave(document.getElementById("save1text"), saved_valid[1]);
  decorateSave(document.getElementById("save2text"), saved_valid[2]);
  decorateSave(document.getElementById("save3text"), saved_valid[3]);
  decorateSave(document.getElementById("save4text"), saved_valid[4]);
  decorateSave(document.getElementById("save5text"), saved_valid[5]);

  decorateDot(document.getElementById("reddot"), state.cb_value);
}


// If shift-click, cycle 0, max, max-1, ...
// If plain click, toggle between 0 and max
function doToggle(shifted, val, max) {
  var newval;
  if (shifted) {
    if (val == 0) {newval = max;} else {newval = val - 1;}
  } else {
    if (val == 0) {newval = max;} else {newval = 0;}
  }
//console.log ("  doToggle", shifted, val, max, "=", newval);
  //d3.event.stopPropagation();
  return newval;
}

// Draw a light gray rectangle at the right margin, beyond the scroll-select area
// This is relative to svgdotg, which is offset by <region1height, region2width>
function redrawIpcLegend() {
  var legendwidth = svgWidth - region2width - region4width;
  if (state.ipc_value > 0) {
    drawipclegend(legendwidth, 0, region234height, region4width); 
  } else {
    drawemptylegend(legendwidth, 0, region234height, region4width);
  }
}


function redrawMarks() {
  // Remove any previous markmarks
  resetmark();

  if (state.marks_value > 0) {
    // Draw markmarks
    ////draw_markmarks();
    redrawEvents();
  }
}

function doToggleCb(e) {
  state.cb_value = doToggle(e.shiftKey, state.cb_value, cb_value_max);
  state.currentcolor = (state.cb_value == 0) ? normalcolor : colorblindcolor;
  redrawUI();
  redrawEvents();
}

function doToggleIpc(e) {
  if (state.ipc_value < 0) {return;}	// unavailable
  state.ipc_value = doToggle(e.shiftKey, state.ipc_value, ipc_value_max);
  //redrawUI();
  //redrawIpcLegend();
  redrawEventsEtc();
}

function doToggleMarks(e) {
  state.marks_value = doToggle(e.shiftKey, state.marks_value, marks_value_max);
  //redrawUI();
  //redrawMarks();
  redrawEventsEtc();
}

function doToggleArcs(e) {
  state.arcs_value = doToggle(e.shiftKey, state.arcs_value, arcs_value_max);
  redrawEventsEtc();
}

function doToggleAnnotateall(e) {
  state.annotateall_value = doToggle(e.shiftKey, state.annotateall_value, 
    annotateall_value_max);

  // Turn off annotateuser if annotateall is active
  if (state.annotateall_value > 0) {state.annotateuser_value = 0;}

  // Remove any previous lines. 
  resetlines();
  redrawUI();

  if (state.annotateall_value > 0) { 
    draw_annotateall();
  }
}

function doToggleAnnotateuser(e) {
  state.annotateuser_value = doToggle(e.shiftKey, state.annotateuser_value, 
    annotateuser_value_max);

  // Turn off annotateall if annotateuser is active
  if (state.annotateuser_value > 0) {state.annotateall_value = 0;}

  // Remove any previous lines. 
  resetlines();
  redrawUI();

  if (state.annotateuser_value > 0) { 
    draw_annotateuser();
  }
}

function doToggleSearchnot(e) {
  state.searchnot_value = doToggle(e.shiftKey, state.searchnot_value, 
    searchnot_value_max);

  // Turn off annotateall/user when search is active
  state.annotateall_value = 0;
  state.annotateuser_value = 0;

  // Remove any previous lines. 
  resetlines();
  redrawUI();

  annotatesearch2(document.getElementById("SearchText").value, 
                  document.getElementById("SearchMin").value,
                  document.getElementById("SearchMax").value);
}


function doToggleTitletext(e) {
  state.textmultiplier_value = doToggle(e.shiftKey, state.textmultiplier_value, 
    textmultiplier_value_max);

  // Update the entire screen 
  allocOuterSvgEtc();
}

function doToggleBasetimetext(e) {
//console.log("doToggleBasetimetext");
  state.basetime0_value = doToggle(e.shiftKey, state.basetime0_value, 
    basetime0_value_max);
  // TBD
}

function getTracksAbove(n) {
  return state.groupfirsttrack[n];
}



// VERYTEMP: not sure best consistency for adding/removing rows
//  The verytemp version keeps top of screen nearly constant
function updateCompressEtc(n) {
  // Remember the clicked label Y position
  var tracksabove = getTracksAbove(n);
  var oldlabelypos = state.grouplabelypos[n];
  var oldmaxTrack = maxTrack;

//VERYTEMP
var temp = state.savedtransformY;

  // Renumber the track heights per row based on new expand/compress value
  updateTracks();

//VERYTEMP
//  y.domain([0, maxTrack]);

  var newmaxTrack = maxTrack;

  // Y-axis range is (2 * axesmargin) short
  // oldlabelypos = region234height * above/oldmax
  // newlableypos = region234height * above/newmax
  var delta = region234height * (tracksabove/oldmaxTrack - tracksabove/newmaxTrack);

//console.log("updateCompressEtc", oldlabelypos, tracksabove, oldmaxTrack, newmaxTrack, delta);

  // WANT TO Alter y_zoomed to put clicked row back where it was vertically 
  // So move Y down by delta
  state.savedtransformY = state.savedtransformY.translate(0, delta);
//VERYTEMP
state.savedtransformY = temp;

  // These are needed to have the restored transforms stick
  panzoomrect_y.call(myZoom_y.transform, state.savedtransformY);
  panzoomrect_y.call(myZoom_y);

//console.log("1 state.savedtransformY", state.savedtransformY);
 
  // Use y_zoomed when drawing everything after this  
  // Set up y_zoomed, x_zoomed and Recalculate Y- and X- on-screen limits

  updateTracks();
  y.domain([0, maxTrack]);
  resetRangeDomain();
  calcPixHeightsPerTrack(ypixpertrack);

  redrawEventsEtc();

  // Axes depend on calculateBasetime in redrawEventsEtc
  // Redraw the zoomed Y-axis
  redrawYlabels();
//console.log("2 state.savedtransformY", state.savedtransformY);
}

function doToggleCompress0(e) {
  state.groupcompress[0] = 
    doToggle(e.shiftKey, state.groupcompress[0], compress_value_max);
  updateCompressEtc(0);
}

function doToggleCompress1(e) {
  state.groupcompress[1] = 
    doToggle(e.shiftKey, state.groupcompress[1], compress_value_max);
  updateCompressEtc(1);
}

function doToggleCompress2(e) {
  state.groupcompress[2] = 
    doToggle(e.shiftKey, state.groupcompress[2], compress_value_max);
  updateCompressEtc(2);
}

function doToggleCompress3(e) {
  state.groupcompress[3] = 
    doToggle(e.shiftKey, state.groupcompress[3], compress_value_max);
  updateCompressEtc(3);
}


function doSaveRestore(shifted, n) {
  if (shifted) {
    // ------ Save -----------------------------------------------------------//
    // Capture current pan/zoom transforms
    savedstate[n] = packupState();
    saved_valid[n] = true;
    redrawUI();
console.log("  doSaveRestore[", n, "] ------ saved");

  } else {
    if (!saved_valid[n]) {
      // ------ Nothing to Restore -------------------------------------------//
      // No state was saved; cannot restore
console.log ("  doSaveRestore[", n, "] ------ CANNOT RESTORE");
      return;
    }

    // ------ Restore --------------------------------------------------------//
    // Swap 0 <== current, current <== n
console.log("  doSaveRestore[", n, "] ------ restoring ...");
    var temp = packupState();
    unpackState(savedstate[n]);

    savedstate[0] = temp;
    saved_valid[0] = true;

    var Xx = state.savedtransformX.x;
    var Xy = state.savedtransformX.y;
    var Xk = state.savedtransformX.k;
    var Yx = state.savedtransformY.x;
    var Yy = state.savedtransformY.y;
    var Yk = state.savedtransformY.k;

    // These reset the transformations to identity, overwriting 
    // savedtransformX/Y, which cannot easily be assigned because 
    // they are functions, not just simple variables.
    redrawUI(); 
    resizeWindowEtc();

    // Now re-apply the saved translations
    state.savedtransformX = d3.zoomIdentity.translate(Xx, Xy).scale(Xk);
    state.savedtransformY = d3.zoomIdentity.translate(Yx, Yy).scale(Yk);

    // These are needed to have the restored transforms stick
    panzoomrect_x.call(myZoom_x.transform, state.savedtransformX);
    panzoomrect_x.call(myZoom_x);
    panzoomrect_y.call(myZoom_y.transform, state.savedtransformY);
    panzoomrect_y.call(myZoom_y);

    // Renumber the track heights per row, to auto-prune rows no longer visibl
    updateTracks();
    y.domain([0, maxTrack]);
    resetRangeDomain();
    calcPixHeightsPerTrack(ypixpertrack);
 
    redrawEventsEtc();

    redrawXaxis();
    ////redrawYaxis();

    redrawYlabels();
console.log("  doSaveRestore[", n, "] ------ restored");
  }
}


function doToggleState0(e) {
  doSaveRestore(e.shiftKey, 0);
}

function doToggleState1(e) {
  doSaveRestore(e.shiftKey, 1);
}

function doToggleState2(e) {
  doSaveRestore(e.shiftKey, 2);
}

function doToggleState3(e) {
  doSaveRestore(e.shiftKey, 3);
}

function doToggleState4(e) {
  doSaveRestore(e.shiftKey, 4);
}

function doToggleState5(e) {
  doSaveRestore(e.shiftKey, 5);
}

function doToggleMore(e) {
console.log("doToggleMore", more_text);
  more_text = !more_text;
  if (more_text) {
    document.getElementById("moretoggle").innerHTML = "[less]";
    document.getElementById("moretext").style.display = "";
  } else {
    document.getElementById("moretoggle").innerHTML = "[more]";
    document.getElementById("moretext").style.display = "none";
  }
}



function fillOuterSvg() {
  // Add the graph title centered over region3
  // 0.8 is approximation that shifts up to allow descenders
  outersvg.append("text") 
      .attr("id", "titletext")            
      .attr("transform", "translate(" + (region2width + region3width/2) + ", " + 
                                    (0.8 * region1height) + ")")
      .attr("font-size", (textsize.title) + "px")
      .attr("font-family", "serif")
      .attr("class", "title-text noselect")
      .style("text-anchor", "middle")
      .style("fill", "blue")
      .text(data.title);

  var xaxisHeight = region5height / 2;


  // TEMP Add the X-axis values 
  //   0.2 is approximation that shifts up to allow descenders
//  outersvg.append("text")             
//      .attr("transform", "translate(" + (svgWidth/2) + ", " +
//            (svgHeight - 1.2 * xaxisHeight) + ")")
//      .attr("font-size", (textsize.tick) + "px")
//      .attr("font-family", "sans-serif")
//      .style("text-anchor", "middle")
//      .style("fill", "black")
//      .text("Dummy X-axis values");

  // TEMP Add the X-axis label line
  // basetime 
  outersvg.append("text") 
      .attr("id", "basetimetext")            
      .attr("transform", "translate(" + (0) + ", " +
            (svgHeight - 0.2 * xaxisHeight) + ")")
      .attr("width", svgWidth)
      .attr("font-size", (textsize.tick) + "px")
      .attr("font-family", "sans-serif")
      .attr("class", "noselect")
      .style("text-anchor", "start")
      .style("fill", "black")
      .text("");				// placeholder

  // X-axis label
  outersvg.append("text")  
      .attr("id", "xaxislabel")           
      .attr("transform", "translate(" + (svgWidth/2) + ", " +
            (svgHeight - 0.2 * xaxisHeight) + ")")
      .attr("font-size", (textsize.label) + "px")
      .attr("font-family", "serif")
      .attr("class", "title-text noselect")
      .style("text-anchor", "middle")
      .style("fill", "blue")
      //.text(data.axisLabelX);		
      .text("");				// placeholder		


  // Set listeners for text areas
  document.getElementById("titletext").addEventListener("click", doToggleTitletext);
  document.getElementById("basetimetext").addEventListener("click", doToggleBasetimetext);
  document.getElementById("save0text").addEventListener("click", doToggleState0);
  document.getElementById("save1text").addEventListener("click", doToggleState1);
  document.getElementById("save2text").addEventListener("click", doToggleState2);
  document.getElementById("save3text").addEventListener("click", doToggleState3);
  document.getElementById("save4text").addEventListener("click", doToggleState4);
  document.getElementById("save5text").addEventListener("click", doToggleState5);

  document.getElementById("moretoggle").addEventListener("click", doToggleMore);
}



// row is sortNum subscript
function getGroup(row) {
  if (row < sortNum_pid_start)      {return prefixCpu;}
  else if (row < sortNum_rpc_start) {return prefixPid;}
  else if (row < sortNum_res_start) {return prefixRpc;}
  else                              {return prefixRes;}
}

// row is sortNum subscript
function getGroupcompress(row) {
  return state.groupcompress[getGroup(row)];
}

// Assign heights for each sortNum, and then which tracks they occupy:
// Height is 10 if row is a group label
// Height is 0 if group is not expanded
// Height is 0 if row is auto-pruned because it's not on screen
// Height is maxTrackHeight if row has highlighted events 
// Height is 1/5/20 based on group compress 
//
function updateTracks() {
  for (var row = 0; row < sortNum.length; ++row) {
    var groupcmpr = getGroupcompress(row);
//console.log("updateTracks row compress", row, groupcmpr, grayHeight[groupcmpr], 
//rowHilite(row));
    if (sortNum[row] < 0) {
      rowToHeight[row] = maxTrackHeight / 2;  // group labels are small
    } else if (groupcmpr == 0) {
      rowToHeight[row] = 0;			// Group is not expanded
    } else if (!rangeonscreen_x(rowToMinT[row], rowToMaxT[row])) {
      rowToHeight[row] = 0;			// Auto-prune if not onscreen
    } else if (rowFullsize(row)) {
      rowToHeight[row] = maxTrackHeight;	// Row has highlighted events
    } else {
      rowToHeight[row] = grayHeight[groupcmpr];	// non-highlighted
    }
  }

  // We keep N+1 rows, to make it easy to have the first-unused track number
  rowToHeight[sortNum.length] = 0;

  rowToTrack[0] = 0;
  for (var row = 1; row <= sortNum.length; ++row) {
    rowToTrack[row] = rowToTrack[row - 1] + rowToHeight[row - 1];
    // Remember where each group starts
    if (sortNum[row] < 0) {
//console.log(sortName[row], "at", rowToTrack[row]); 
      var prefix = -sortNum[row] - 1;
      state.groupfirsttrack[prefix] = rowToTrack[row];
    }
  }
  // First unused track is rowToTrack[sortNum.length]
  maxTrack = rowToTrack[sortNum.length];
//console.log("maxTrack", maxTrack);
//console.log("rowToHeight", rowToHeight);
//console.log("rowToTrack", rowToTrack);

  // NO. y is set up a bit later. Remap the Y-axis to reflect the current maxtrack
  //y.domain([0, maxtrack]);
}

// Split the incoming traceable string into the day part (as a string)
// and the time part (as numeric seconds). Then we can do arithmetic 
// on the seconds part to offset the base time of the X-axis.
//   "tracebase" : "2016-11-19_10:04:00"
//                  dddddddddd tttttttt
function splitTracebase() {
  dataBaseDate = data.tracebase.substr(0,10);
  dataBaseSecond = 
    (+data.tracebase.substr(11,2) * 3600) +
    (+data.tracebase.substr(14,2) * 60) +
    (+data.tracebase.substr(17,2));
//console.log(dataBaseDate, dataBaseSecond, hhmmss(dataBaseSecond + 0.123), "06.3f");
}

function low16of(x) {
  return x & 0xFFFF;
}


function getDataMetadata(data) {
  // Pick out all the unique CPU, PID. RPCID, and Resource values with their names
  // First pass over all the data
  let uniqCpu = new Map();
  let uniqPid = new Map();
  let uniqRpc = new Map();
  let uniqRes = new Map();
  // Ignore all -1 items
  data.events.forEach(function(d) {
    var cpu16 = low16of(cpu(d));
    var pid16 = low16of(pid(d));
    var rpc16 = low16of(rpc(d));
    var res16 = low16of(res(d));

    // Captures name at first use. Without !has test, would get last use
    // Ignore pid=0 (idle job) and rpc=0 (no RPC active)
    if ((0 <= cpu(d)) && !uniqCpu.has(cpu16)) {
      uniqCpu.set(cpu16, cpu(d).toString());
    }
    if ((0 < pid(d)) && (is_useroridle(d)) && !uniqPid.has(pid16)) {
      uniqPid.set(pid16, name(d));
    }
    if ((0 < rpc(d)) && !uniqRpc.has(rpc16)) {
      uniqRpc.set(rpc16, name(d));
    }
    if ((0 <= res(d)) && !uniqRes.has(res16)) {
      uniqRes.set(res16, name(d));
    }
  });

 
// Sets are in order of insertion. 
// This is what we want for RPC IDs, but not the others, which we want 
//   ascending numerically
//console.log("metadata Cpu", uniqCpu);
//console.log("metadata Pid", uniqPid);
//console.log("metadata Rpc", uniqRpc);
//console.log("metadata Res", uniqRes);
  var sortCpu = [...uniqCpu];	//[ [k1,v1], [k2,v2], ... ]
  var sortPid = [...uniqPid];
  var sortRpc = [...uniqRpc];
  var sortRes = [...uniqRes];
  sortCpu.sort(function(a, b){return a[0]-b[0]});
  sortPid.sort(function(a, b){return a[0]-b[0]});
  // Leave sortRpc alone -- already in order of occurrence
  sortRes.sort(function(a, b){return a[0]-b[0]});

//console.log("metadata Cpu", sortCpu);
//console.log("metadata Pid", sortPid);
//console.log("metadata Rpc", sortRpc);
//console.log("metadata Res", sortRes);

  var sortCpuNum = sortCpu.map(function(v){ return v[0] });
  var sortCpuName = sortCpu.map(function(v){ return v[1] });

  var sortPidNum = sortPid.map(function(v){ return v[0] });
  var sortPidName = sortPid.map(function(v){ return v[1] });
  ////if (sortPidNum[0] == 0) {sortPidName[0] = "-idle-";}

  var sortRpcNum = sortRpc.map(function(v){ return v[0] });
  var sortRpcName = sortRpc.map(function(v){ return v[1] });

  var sortResNum = sortRes.map(function(v){ return v[0] });
  var sortResName = sortRes.map(function(v){ return v[1] });

//console.log(sortPidNum);
//console.log(sortPidName);

  // Build sortNum list of every row we can ever display
  // Negative values are rows for group names
  // If the size of a group is zero, delete it entirely
  sortNum = [];
  if (sortCpuNum.length > 0) {sortNum = sortNum.concat([-prefixCpu-1, ...sortCpuNum]);}
  if (sortPidNum.length > 0) {sortNum = sortNum.concat([-prefixPid-1, ...sortPidNum]);}
  if (sortRpcNum.length > 0) {sortNum = sortNum.concat([-prefixRpc-1, ...sortRpcNum]);}
  if (sortResNum.length > 0) {sortNum = sortNum.concat([-prefixRes-1, ...sortResNum]);}

  //sortNum = [-prefixCpu-1, ...sortCpuNum,
  //               -prefixPid-1, ...sortPidNum,
  //               -prefixRpc-1, ...sortRpcNum,
  //               -prefixRes-1, ...sortResNum];
console.log("sortNum ", sortNum);

  // Parallel array of names for Y-axis labels. 
  // We only separate these to make RowToTrack[EventToRow[prefix + f(d)]] fast
  // If the size of a group is zero, delete it entirely
  // MAYBE separation is not needed
  sortName = [];
  if (sortCpuName.length > 0) {sortName = sortName.concat(["CPU", ...sortCpuName]);}
  if (sortPidName.length > 0) {sortName = sortName.concat(["PID", ...sortPidName]);}
  if (sortRpcName.length > 0) {sortName = sortName.concat(["RPC", ...sortRpcName]);}
  if (sortResName.length > 0) {sortName = sortName.concat(["RES", ...sortResName]);}

  // sortName = ["CPU", ...sortCpuName,
  //             "PID", ...sortPidName,
  //             "RPC", ...sortRpcName,
  //             "RES", ...sortResName];
console.log("sortName ", sortName);
  sortNumSize = sortNum.length;


  // NEXT: make one 256K-entry array mapping (prefixCpu * 65536) + low16of(cpu), etc. 
  //   to sortNum subscript 
  eventToRow = new Array(256 * 1024).fill(-1);

  // Group names at sortNum[0] and three later, so the +1's
  sortNum_cpu_start = 1;
  sortNum_pid_start = 1 + sortCpu.length + 1;
  sortNum_rpc_start = 1 + sortCpu.length + 1 + sortPid.length + 1;
  sortNum_res_start = 1 + sortCpu.length + 1 + sortPid.length + 1 + sortRpc.length + 1;
  state.grouplength[prefixCpu] = sortCpu.length;
  state.grouplength[prefixPid] = sortPid.length;
  state.grouplength[prefixRpc] = sortRpc.length;
  state.grouplength[prefixRes] = sortRes.length;

  sortCpuNum.forEach(function(d, i) {
    eventToRow[prefixCpu * 65536 + d] = sortNum_cpu_start + i;});
  sortPidNum.forEach(function(d, i) {
    eventToRow[prefixPid * 65536 + d] = sortNum_pid_start + i;});
  sortRpcNum.forEach(function(d, i) {
    eventToRow[prefixRpc * 65536 + d] = sortNum_rpc_start + i;});
  sortResNum.forEach(function(d, i) {
    eventToRow[prefixRes * 65536 + d] = sortNum_res_start + i;});

//console.log("eventToRow ", eventToRow);

  // Next, find start/end range for each sortNum
  // Second pass over all the data
  rowToMinT = new Array(sortNum.length).fill(999);
  rowToMaxT = new Array(sortNum.length).fill(-1);

  // Also capture initial X-axis bounds
  dataTsLo = 999;
  dataTsHi = 0;
  var row;
  data.events.forEach(function(d) {
    if (0 <= cpu(d)) {
      row  = eventToRow[prefixCpu * 65536 + low16of(cpu(d))];
      if (row >= 0) {
        rowToMinT[row] = Math.min(rowToMinT[row], ts(d));
        rowToMaxT[row] = Math.max(rowToMaxT[row], tsend(d));
        dataTsLo =  Math.min(dataTsLo, ts(d));
        dataTsHi = Math.max(dataTsHi, tsend(d));
      }
    }
    if (0 < pid(d)) {		// Do not draw pid=0, idle
      row  = eventToRow[prefixPid * 65536 +low16of(pid(d))];
      if (row >= 0) {
        rowToMinT[row] = Math.min(rowToMinT[row], ts(d));
        rowToMaxT[row] = Math.max(rowToMaxT[row], tsend(d));
      }
    }
    if (0 < rpc(d)) {		// Do not draw rpc=0, not inside an RPC
      row  = eventToRow[prefixRpc * 65536 +low16of(rpc(d))];
      if (row >= 0) {
        rowToMinT[row] = Math.min(rowToMinT[row], ts(d));
        rowToMaxT[row] = Math.max(rowToMaxT[row], tsend(d));
      }
    }
    //if (0 <= res(d)) {...}	// Later: locks, disks, networks
  });

  // Initial X-axis bounds just after data load, before any pan/zoom
  realxleft = dataTsLo;
  realxright = dataTsHi;
  realxrightmost = dataTsHi;	  // includes the margin.right padding

//console.log("rowToMinT ", rowToMinT);
//console.log("rowToMaxT ", rowToMaxT);
//console.log("X: ", realxleft, "..", realxright);

  // Initialize rowToHighlighted
  //rowToHighlighted = new Array(sortNum.length).fill(true);

//VERYTEMP to test varying heights
  rowToHighlighted = new Array(sortNum.length).fill(false);

  // Now fill in rowToHeight  and rowToTrack 
  rowToHeight = new Array(sortNum.length).fill(10);
  rowToTrack  = new Array(sortNum.length).fill(0);
  // No update of y.domain here -- not created yet
  updateTracks();

//console.log("rowToHeight ", rowToHeight);
//console.log("rowToTrack ", rowToTrack);

  // Pick off date and time
  splitTracebase();
}




// Use new data
function newdata2(data2) {
  //console.log("newdata2:", data2);
  initializeState();	// With new data, start entirely clean on state
 
  // format the data
  data2.events.forEach(function(d) {
      d[0] = +d[0];
      d[1] = +d[1];
      d[2] = +d[2];
      d[3] = +d[3];
      d[4] = +d[4];
      d[5] = +d[5];
      d[6] = +d[6];
      d[7] = +d[7];
      d[8] = +d[8];
  });
 
  data = data2;
  // Remove the 999.0 marker at the end
  data.events.pop();
  data2 = [];
  // Grab the IPC flag; ipc_value=-1 means not IPC data available
  state.ipc_value = 0;
  if ((data.flags & 128) == 0) {state.ipc_value = -1;}
 
  // Get the side arrays
  getDataMetadata(data);
};

function newdata2_resize(data2) {
  if (data2 == null) {
    data2 = dummyData;
  }
  newdata2(data2);
  resizeWindowEtc();
}
 
// Want at least two characters for active searchng
function IsActiveText(t) {
  return t.length >= 1;
}

// Want more than one digit for active searchng
function IsActiveNumber(n) {
  return +n >= 1;
}

//creates a listener for when you press a key
//window.onkeyup = keyup;

function keyupFile(e) {
  // Setting your input text to the global Javascript Variable for every key press
  var inputTextValue = e.target.value;
  state.filename_text = inputTextValue;
 
  // Listens for you to press the ENTER key, at which point your web address will 
  // change to the one you have input in the file box
  if (e.keyCode == 13) {
    if (inputTextValue.substr(0,4) != "http") {
      inputTextValue = "http://127.0.0.1:8000/" + inputTextValue;
    }
    console.log("url:", inputTextValue);
    d3.json(inputTextValue, newdata2_resize);
  }
}

function keyupSearch(e) {
  // Setting your input text to the global Javascript Variable for every key press
  var inputTextValue = e.target.value;
  state.search_text = inputTextValue;

  // Turn off annotateall/user when search is active
  state.annotateall_value = 0;
  state.annotateuser_value = 0;

  if (IsActiveText(inputTextValue)) {e.target.style.backgroundColor= kActiveBackColor;}
  else                              {e.target.style.backgroundColor= kInactiveBackColor;}
 
  annotatesearch2(document.getElementById("SearchText").value, 
                  document.getElementById("SearchMin").value,
                  document.getElementById("SearchMax").value);
  return;
}

function keyupSearchMin(e) {
  // Setting your input text to the global Javascript Variable for every key press
  var inputTextValue = e.target.value;
  state.usec_lo_text = inputTextValue;

  // Turn off annotateall/user when search is active
  state.annotateall_value = 0;
  state.annotateuser_value = 0;

  if (IsActiveNumber(inputTextValue)) {e.target.style.backgroundColor= kActiveBackColor;}
  else                                {e.target.style.backgroundColor= kInactiveBackColor;}
 
  annotatesearch2(document.getElementById("SearchText").value, 
                  document.getElementById("SearchMin").value,
                  document.getElementById("SearchMax").value);
  return;
}

function keyupSearchMax(e) {
  // Setting your input text to the global Javascript Variable for every key press
  var inputTextValue = e.target.value;
  state.usec_hi_text = inputTextValue;

  // Turn off annotateall/user when search is active
  state.annotateall_value = 0;
  state.annotateuser_value = 0;

  if (IsActiveNumber(inputTextValue)) {e.target.style.backgroundColor= kActiveBackColor;}
  else                                {e.target.style.backgroundColor= kInactiveBackColor;}
 
  annotatesearch2(document.getElementById("SearchText").value, 
                  document.getElementById("SearchMin").value,
                  document.getElementById("SearchMax").value);
  return;
}

 
// Main JavaScript program
// Wait for a file name keyup = CR

<!-- selfcontained2 -->


// Re-allocate outer SVG as function of browser window, and 
// redraw everything inside as function of state, data
function allocOuterSvgEtc() {
//console.log("3 state.savedtransformY", state.savedtransformY);

  allocOuterSvg();
  fillOuterSvg();
  redrawUI();
		
  // Renumber the track heights per row, to auto-prune rows no longer visible
  // No update of y.domain here -- not created yet
  updateTracks();
  setInitialRangeDomain();

  // redrawData does redrawIpc, redrawMarks. redrawLast.
  redrawEventsEtc();

  // Axes depend on calculateBasetime in redrawEventsEtc
  drawInitialAxes();

  drawInitialPanZoom();
//console.log("5 state.savedtransformY", state.savedtransformY);

}

// Start over with new data but old window
function newdataEtc(mydata) {
  newdata2(mydata);

  allocOuterSvgEtc();
}

// Start over with new window size but old data, if any
function resizeWindowEtc() {
  allocOuterSvgEtc();
}

//----------------------------------------------------------------------------//
// Initialization function definition                                         //
//----------------------------------------------------------------------------//

function initAll() {
  // Initialize button values and other state
  initializeState();

  // Set listeners for buttons
  document.getElementById("showcb").onclick = doToggleCb;
  document.getElementById("showipc").onclick = doToggleIpc;
  document.getElementById("showmarks").onclick = doToggleMarks;
  document.getElementById("showarcs").onclick = doToggleArcs;
  document.getElementById("annotateall").onclick = doToggleAnnotateall;
  document.getElementById("annotateuser").onclick = doToggleAnnotateuser;
  document.getElementById("searchnot").onclick = doToggleSearchnot;

  // Set listener for windowsize
  window.addEventListener("resize", resizeWindowEtc);
  // Load initial data, if any
  if (typeof(myString) !== 'undefined') {
    var data2 = JSON.parse(myString);
    newdata2(data2);
  }

  // Use the initial window size to calculate svg size
  resizeWindowEtc();
}

// List of UI active areas
// Text input
//  File: Search: usec: lo/hi
// Buttons
//  CB 	color blind colors 	off/on
//  IPC instructions per cycle	off/both/user/kernel
//  Marks                       off/both/txt/number
//  Annotate annotate all	off/on
//  User-mode annotate user	off/on
//  !	invert search		off/on
//  || 1 2 3 4 5		shift-click:save, click:restore
//  [more]			off/on
//  Red dot resets display	
// Active but no indication
//  Title	text size	1.0/1.25/1.50/0.75
//  Y-axis group triangles	collapse/expand/gray=one-fourth/gray=one-twentyith
//  X-axis labels (and body)	pan/zoon
//  Y-axis labels		pan/zoom
//  Y-axis labels		shift-click:normal/highlight
//  Basetime date		normal/relative to row start

//============================================================================//
// End JavaScript. Body follows                                               //
//============================================================================//
</script>
</head>
 

<body onload="initAll()">
File: <input name="FileName" type="text" maxlength="256" id="FileName" class="Filename" onkeyup="keyupFile(event)" style="width: 150px"/> 
<!-- trace_hello_world_small.json for example -->

<button id="showcb"  style="border-radius:6px";>CB</button>
<button id="showipc"  style="border-radius:6px";>IPC</button>
<button id="showmarks"  style="border-radius:6px";>Marks</button>
<button id="showarcs"  style="border-radius:6px";>Arcs</button>
Annot:
<button id="annotateall"  style="border-radius:6px";>All</button>
<button id="annotateuser"  style="border-radius:6px";>User</button>

Search: 
<button id="searchnot"; style="background-color:#FFFFFF; color:#808080; borderColor:#C0C0C0; border-radius:6px";>!</button>

<input name="SearchText" type="text" maxlength="256" id="SearchText" class="Searchtext" onkeyup="keyupSearch(event)" style="width: 150px; background-color:#FFFFFF"/> 

usec:
<input name="SearchMin" type="text" maxlength="20" id="SearchMin" class="Searchmin" onkeyup="keyupSearchMin(event)" style="width: 30px; background-color:#FFFFFF"/> 
..
<input name="SearchMax" type="text" maxlength="20" id="SearchMax" class="Searchmax" onkeyup="keyupSearchMax(event)" style="width: 30px; background-color:#FFFFFF"/>

Matches: 
<span id="matchcount"></span>
<br>

<!-- All the drawing is done in an SVG element allocated inside here -->
<span id="anchorsvg"></span>

<br>
<!--  
  // Six save/restore clickable items 
  // Up down double arrow U+21d5
  // Dingbat circled sans-serif digit one..five U+2780..2785
 -->
<span style="font-family:sans-serif; font-size:20px" id="save0text" class="noselect">&#x21d5;</span>

<span style="font-family:sans-serif; font-size:20px" id="save1text" class="noselect">&#x2780;</span>

<span style="font-family:sans-serif; font-size:20px" id="save2text" class="noselect">&#x2781;</span>

<span style="font-family:sans-serif; font-size:20px" id="save3text" class="noselect">&#x2782;</span>

<span style="font-family:sans-serif; font-size:20px" id="save4text" class="noselect">&#x2783;</span>

<span style="font-family:sans-serif; font-size:20px" id="save5text" class="noselect">&#x2784;</span>

<span style="font-family:sans-serif; font-size:12px; color:blue">
  Shift-click 1-5 to save, click to restore. Axes: scroll wheel to zoom, 
  drag to pan. Items: shift-click-unclick to annotate. 
  Shift-click-unshift to keep, shift-drag to measure. 
  Red dot resets. <span style="font-weight: bold" id="moretoggle">[more]</span>
  
  <span id="moretext" style=”display:none”>
<pre>
   +------------------------------------------------------------------------+
   |            (0) UI controls (HTML)                                      |
   +------------------------------------------------------------------------+
   |            (1) Title                                                   |
   +----+--------------------------------------------------------------+----+
   |(2) |                                                              |(4) |
   |Y-  |       (3) Main SVG drawing area                              |IPC |
   |axis|                                                              |    |
   |    |                                                              |    |
   +----+--------------------------------------------------------------+----+
   |            (5) X-axis                                                  |
   +----+--------------------------------------------------------------+----+
   |            (6) UI hint text (HTML)                                     |
   +----+--------------------------------------------------------------+----+

   List of UI active areas
   In general, click toggles buttons while shift-click cycles through more choices
   In general, shift-click-unclick to annotate/highlight; shift-click-unshift to 
     keep multiple results onscreen at once
  
   (0) Text and buttons
     File: 	[defunct] URL of json to load
     CB   color blind colors 	 off/on
     IPC  instructions per cycle off/both/user/kernel
     Marks      mark_x events	 off/both/text/numbers
     Annotate   annotate all	 off/on
     User-mode  annotate user	 off/on
     Search:    regex string match 
     !	        invert search	 off/on, like grep -v
     usec:      match only event duration in [lo..hi]
  
   (1) Title	text size	1.0/1.25/1.50/0.75 times default
  
   (2) Y-axis group triangles	collapse/expand/gray=one-fourth/gray=one-twentieth
       Y-axis labels		mouse and wheel to pan/zoom vertically
       Y-axis labels		shift-click:normal/highlight
  
   (3) anywhere 		mouse and wheel to pan/zoom horizntally	
     Red dot 			resets display
  
   (5) Basetime date		normal/relative to row start
  
   (6) Buttons
     1 2 3 4 5			shift-click:save, click:restore current view
     double-arrow		toggles between last two views
     [more]			this text off/on
</pre>

  </span>
</span>

<!--
<span style="font-family:sans-serif; font-size:10px">
  10: to zoom, 
</span>
<span style="font-family:sans-serif; font-size:8px">
  8: click-drag 
</span>
<span style="font-family:sans-serif; font-size:6px">
  6: to pan. 
</span>
-->
 
</body> 
</html>

